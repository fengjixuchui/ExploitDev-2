#include <windows.h>
#include <WinSock2.h>
#include <stdio.h>
#include <stdint.h>

int32_t wmain(int32_t nArgc, const wchar_t *pArgv[]) {
    WSADATA WsaData = { 0 };

    if ((WSAStartup(0x202, &wsaData)) == 0) {


    if (port == 0)

    {

        Usage(argv[0]);

    }



    local.sin_family = AF_INET;

    local.sin_addr.s_addr = (!ip_address) ? INADDR_ANY : inet_addr(ip_address);



    /* Port MUST be in Network Byte Order */

    local.sin_port = htons(port);

    // TCP socket

    listen_socket = socket(AF_INET, socket_type, 0);



    if (listen_socket == INVALID_SOCKET) {

        fprintf(stderr, "Server: socket() failed with error %d\n", WSAGetLastError());

        WSACleanup();

        return -1;

    }

    else

    printf("Server: socket() is OK.\n");



    // bind() associates a local address and port combination with the socket just created.

    // This is most useful when the application is a

    // server that has a well-known port that clients know about in advance.

    if (bind(listen_socket, (struct sockaddr*)&local, sizeof(local)) == SOCKET_ERROR)

    {

        fprintf(stderr, "Server: bind() failed with error %d\n", WSAGetLastError());

        WSACleanup();

        return -1;

    }

    else

    printf("Server: bind() is OK.\n");



    // So far, everything we did was applicable to TCP as well as UDP.

    // However, there are certain steps that do not work when the server is

    // using UDP. We cannot listen() on a UDP socket.

    if (socket_type != SOCK_DGRAM)

    {

        if (listen(listen_socket, 5) == SOCKET_ERROR)

        {

            fprintf(stderr, "Server: listen() failed with error %d\n", WSAGetLastError());

            WSACleanup();

            return -1;

        }

        else

            printf("Server: listen() is OK.\n");

    }

    printf("Server: %s: I'm listening and waiting connection\non port %d, protocol %s\n", argv[0], port, (socket_type == SOCK_STREAM) ? "TCP" : "UDP");



    while (1)

    {

        fromlen = sizeof(from);

        // accept() doesn't make sense on UDP, since we do not listen()

        if (socket_type != SOCK_DGRAM)

        {

            msgsock = accept(listen_socket, (struct sockaddr*)&from, &fromlen);

            if (msgsock == INVALID_SOCKET)

            {

                fprintf(stderr, "Server: accept() error %d\n", WSAGetLastError());

                WSACleanup();

                return -1;

            }

            else

                printf("Server: accept() is OK.\n");

            printf("Server: accepted connection from %s, port %d\n", inet_ntoa(from.sin_addr), htons(from.sin_port));



        }

        else

            msgsock = listen_socket;



        // In the case of SOCK_STREAM, the server can do recv() and send() on

        // the accepted socket and then close it.

        // However, for SOCK_DGRAM (UDP), the server will do recvfrom() and sendto()  in a loop.

        if (socket_type != SOCK_DGRAM)

            retval = recv(msgsock, Buffer, sizeof(Buffer), 0);



        else

        {

            retval = recvfrom(msgsock, Buffer, sizeof(Buffer), 0, (struct sockaddr*)&from, &fromlen);

            printf("Server: Received datagram from %s\n", inet_ntoa(from.sin_addr));

        }



        if (retval == SOCKET_ERROR)

        {

            fprintf(stderr, "Server: recv() failed: error %d\n", WSAGetLastError());

            closesocket(msgsock);

            continue;

        }

        else

            printf("Server: recv() is OK.\n");



        if (retval == 0)

        {

            printf("Server: Client closed connection.\n");

            closesocket(msgsock);

            continue;

        }

        printf("Server: Received %d bytes, data \"%s\" from client\n", retval, Buffer);



        printf("Server: Echoing the same data back to client...\n");

        if (socket_type != SOCK_DGRAM)

            retval = send(msgsock, Buffer, sizeof(Buffer), 0);

        else

            retval = sendto(msgsock, Buffer, sizeof(Buffer), 0, (struct sockaddr*)&from, fromlen);



        if (retval == SOCKET_ERROR)

        {

            fprintf(stderr, "Server: send() failed: error %d\n", WSAGetLastError());

        }

        else

            printf("Server: send() is OK.\n");



        if (socket_type != SOCK_DGRAM)

        {

            printf("Server: I'm waiting more connection, try running the client\n");

            printf("Server: program from the same computer or other computer...\n");

            closesocket(msgsock);

        }

        else

            printf("Server: UDP server looping back for more requests\n");

        continue;

    }

    return 0;
}
