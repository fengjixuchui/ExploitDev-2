#include <Windows.h>
#include <stdio.h>
#include <stdint.h>
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

#include "PeFile.hpp"
#include "MitigationlessPe.hpp"

using namespace std;

MitigationlessPe::MitigationlessPe(const wstring& PePath, uint64_t qwMitigationFlags) : Path(PePath) {
	this->PePhys = PeFile::Load(this->Path, false);

	if (this->PePhys) {
		if (this->PePhys->GetEntryPointRVA()) { // There are edge cases for PEs that contain no code which are irrelevant. For example, 64-bit PEs with no exception directory (but which contain no code)
			uint32_t dwRelocationsRva, dwRelocationsSize;
			this->CFG = ((this->PePhys->GetDllCharacteristics() & IMAGE_DLLCHARACTERISTICS_GUARD_CF));
			this->ASLR = ((this->PePhys->GetDllCharacteristics() & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE));
			this->DEP = ((this->PePhys->GetDllCharacteristics() & IMAGE_DLLCHARACTERISTICS_NX_COMPAT));
			this->SecureExceptions = this->PePhys->ExceptionsSecure();
			this->Relocations = this->PePhys->GetDataDir(IMAGE_DIRECTORY_ENTRY_BASERELOC, dwRelocationsRva, dwRelocationsSize);

			// Discard PE if mitigation being searched for is present

			if ((!this->ASLR || !this->Relocations) && (qwMitigationFlags & SEARCH_FLAG_ASLR) || !this->SecureExceptions && (qwMitigationFlags & SEARCH_FLAG_SECURE_EXCEPTIONS) || !this->CFG && (qwMitigationFlags & SEARCH_FLAG_CFG) || !this->DEP && (qwMitigationFlags & SEARCH_FLAG_DEP)) {}
			else {
				throw 3;
			}
		}
		else {
			throw 2;
		}
	}
	else {
		throw 1;
	}
}

void MitigationlessPe::Print() const {
	printf("| %ws [%ws]\r\n", this->Path.c_str(), this->PePhys->RequiredPeArchStr().c_str());
	
	if (this->PePhys->IsPe64()) { // Since GetImageBase is not (and cannot) be declared in the PeFile abstract base class due to varying non-covariance compatible return types, it is unique among all PeFile methods in that it requires explicit casting to the derived type before it can be called.
		printf("|__ Image base: 0x%016llx\r\n", dynamic_cast<PeArch64*>(this->PePhys.get())->GetImageBase());
		printf("  | Secure exceptions: %ws\r\n", this->HasSecureExceptions() ? L"true" : L"false");
	}
	else {
		printf("|__ Image base: 0x%08x\r\n", dynamic_cast<PeArch32*>(this->PePhys.get())->GetImageBase());
		printf("  | SafeSEH: %ws\r\n", this->HasSecureExceptions() ? L"true" : L"false");
	}

	printf("  | CFG: %ws\r\n", this->CFG ? L"true" : L"false");
	printf("  | DEP: %ws\r\n", this->DEP ? L"true" : L"false");

	if (this->ASLR) {
		if (this->Relocations) {
			printf("  | ASLR: true\r\n\r\n");
		}
		else {
			printf("  | ASLR: false [no relocations]\r\n\r\n");
		}
	}
	else {
		printf("  | ASLR: false [explicit]\r\n\r\n");
	}
}

#define ArrayLength(a) (sizeof(a) / sizeof(a[0]))
#define SizeInWideChars(x) (sizeof(x) / sizeof(wchar_t))

vector<MitigationlessPe> MitigationlessPe::ScanFiles(const wstring& TargetPath, uint64_t qwMitigationFlags, uint32_t &rdwTotalPe) {
	wchar_t PreviousDirectory[MAX_PATH + 1] = { 0 }, CurrentDirectory[MAX_PATH + 1] = { 0 };
	WIN32_FIND_DATAW Wfd = { 0 };
	HANDLE hFindData;
	vector<MitigationlessPe> PeVec;

	GetCurrentDirectoryW(SizeInWideChars(PreviousDirectory), PreviousDirectory);

	if (SetCurrentDirectoryW(TargetPath.c_str())) {
		GetCurrentDirectoryW(SizeInWideChars(CurrentDirectory), CurrentDirectory);

		if ((hFindData = FindFirstFileW(L"*", &Wfd)) != INVALID_HANDLE_VALUE) {
			do {
				if (_wcsicmp(Wfd.cFileName, L".") != 0 && _wcsicmp(Wfd.cFileName, L"..") != 0) {
					if ((Wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
						vector<MitigationlessPe> NewVec = MitigationlessPe::ScanFiles(Wfd.cFileName, qwMitigationFlags, rdwTotalPe);
						PeVec.insert(PeVec.end(), make_move_iterator(NewVec.begin()), make_move_iterator(NewVec.end()));
					}
					else {
						wchar_t FullPath[MAX_PATH + 1] = { 0 };

						wcscpy_s(FullPath, SizeInWideChars(FullPath), CurrentDirectory);
						wcscat_s(FullPath, SizeInWideChars(FullPath), L"\\");
						wcscat_s(FullPath, SizeInWideChars(FullPath), Wfd.cFileName);

						try {
							PeVec.push_back(MitigationlessPe(FullPath, qwMitigationFlags));
							rdwTotalPe++;
						}
						catch (int32_t nError) {
							if (nError == 3) {
								rdwTotalPe++;
							}
						}
					}
				}
			} while (FindNextFileW(hFindData, &Wfd));
		}

		FindClose(hFindData);
	}

	SetCurrentDirectoryW(PreviousDirectory);

	return PeVec;
}
