#include "stdafx.h"
#include "sdk.hpp"

#pragma comment(lib, "procmonsdk.lib")

#define DLL_INJECTOR_PATH32 L"C:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\InjectDLL\\Release\\InjectDLL32.exe"
#define DLL_INJECTOR_PATH64 L"C:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\InjectDLL\\x64\\Release\\InjectDLL64.exe"
#define SCYTHE_HOOK_DLL_PATH32 L"c:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\ScytheHook\\Release\\ScytheHookDll32.dll"
#define SCYTHE_HOOK_LOG_PATH32 L"C:\\ProgramData\\ScytheHook32.log"
#define SCYTHE_HOOK_DLL_PATH64 L"c:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\ScytheHook\\x64\\Release\\ScytheHookDll64.dll"
#define SCYTHE_HOOK_LOG_PATH64 L"C:\\ProgramData\\ScytheHook64.log"

shared_ptr<Interface> Intf;
shared_ptr<ApiTable> DynamicApis;

bool LaunchDllInjector(uint32_t dwTargetPid) {
	STARTUPINFOW StartupInfo = { 0 };
	PROCESS_INFORMATION ProcessInfo = { 0 };
	wchar_t CommandLine[1000] = { 0 };
	bool bSuccess = false;

	StartupInfo.cb = sizeof(StartupInfo);

	try {
		Process NewPs(Intf, DynamicApis, dwTargetPid, L"");
		
		Intf->Log("... successfully initialized class object for PID %d\r\n", dwTargetPid);

		if (NewPs.IsWow64()) {
			_snwprintf(CommandLine, 1000, L"%ws %d %ws %ws", DLL_INJECTOR_PATH32, dwTargetPid, SCYTHE_HOOK_DLL_PATH32, SCYTHE_HOOK_LOG_PATH32);
		}
		else {
			_snwprintf(CommandLine, 1000, L"%ws %d %ws %ws", DLL_INJECTOR_PATH64, dwTargetPid, SCYTHE_HOOK_DLL_PATH64, SCYTHE_HOOK_LOG_PATH64);
		}
	}
	catch (int32_t nError) {
		Intf->Log("... failed to initialize class object for PID %d\r\n", dwTargetPid);
	}

	return bSuccess;
}

class CMyEvent : public IEventCallback
{
public:
	virtual BOOL DoEvent(const CRefPtr<CEventView> pEventView)
	{
		if(pEventView->GetEventClass() == MONITOR_TYPE_PROCESS) {
			/*
			ULONGLONG Time = pEventView->GetStartTime().QuadPart;

			LogMessage(L_INFO, TEXT("%llu Process %s Do 0x%x %s for %s"),
				Time,
				pEventView->GetProcessName().GetBuffer(),
				pEventView->GetEventOperator(),
				StrMapOperation(pEventView->GetPreEventEntry()),
				pEventView->GetPath().GetBuffer());

			if (pEventView->GetEventOperator() == LOG_PROCESS_NOTIFY_TYPE::NOTIFY_PROCESS_CREATE) {
				printf("! PROCESS CREATE\r\n");
			}
			else if (pEventView->GetEventOperator() == LOG_PROCESS_NOTIFY_TYPE::NOTIFY_PROCESS_START) {
				printf("! PROCESS START\r\n");
			}
			else if (pEventView->GetEventOperator() == LOG_PROCESS_NOTIFY_TYPE::NOTIFY_PROCESS_INIT) {
				printf("! PROCESS INIT: %ws %d parent %d\r\n", pEventView->GetImagePath().GetBuffer(), pEventView->GetProcessId(), pEventView->GetParentProcessId());
			}
			*/

			if (pEventView->GetEventOperator() == LOG_PROCESS_NOTIFY_TYPE::NOTIFY_PROCESS_INIT) {
				printf("... new process creation event: %ws (PID %d) launched from parent %d\r\n", pEventView->GetImagePath().GetBuffer(), pEventView->GetProcessId(), pEventView->GetParentProcessId());

				if (wcsstr(pEventView->GetImagePath().GetBuffer(), L"InjectDLL") == nullptr) {
					//
				}
			}
		}
		return TRUE;
	}
};


int main()
{

	CEventMgr& Optmgr = Singleton<CEventMgr>::getInstance();
	CMonitorContoller& Monitormgr = Singleton<CMonitorContoller>::getInstance();
	CDrvLoader& Drvload = Singleton<CDrvLoader>::getInstance();
	Intf = make_shared<Interface>(true, VerbosityLevel::Surface);
	DynamicApis = make_shared<ApiTable>(Intf);

	if (!Drvload.Init(TEXT("PROCMON24"), TEXT("procmon.sys"))) {
		return -1;
	}
	Optmgr.RegisterCallback(new CMyEvent);

	//
	// Try to connect to procmon driver
	//

	if (!Monitormgr.Connect()) {
		LogMessage(L_ERROR, TEXT("Cannot connect to procmon driver"));
		return -1;
	}

	//
	// try to start monitor
	//

	Monitormgr.SetMonitor(TRUE, TRUE, FALSE);
	if (!Monitormgr.Start()) {
		LogMessage(L_ERROR, TEXT("Cannot start the mointor"));
		return -1;
	}

	system("pause");

	//
	// try to stop the monitor
	//

	Monitormgr.Stop();

	LogMessage(L_INFO, TEXT("!!!!!monitor stop press any key to start!!!!"));
	system("pause");

	Monitormgr.Start();

	system("pause");

	Monitormgr.Stop();
	Monitormgr.Destory();
	return 0;
}