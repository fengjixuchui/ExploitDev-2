#include "stdafx.h"
#include "Install.h"
#include "sdk.hpp"

#pragma comment(lib, "procmonsdk.lib")

bool LaunchDllInjector(uint32_t dwTargetPid) {
	STARTUPINFOW StartupInfo = { 0 };
	PROCESS_INFORMATION ProcessInfo = { 0 };
	wchar_t CommandLine[1000] = { 0 };
	bool bSuccess = false;

	StartupInfo.cb = sizeof(StartupInfo);

	try {
		Process NewPs(Intf, DynamicApis, dwTargetPid, L"");

		Intf->Log("... successfully initialized class object for PID %d\r\n", dwTargetPid);

		if (NewPs.IsWow64()) {
			_snwprintf(CommandLine, 1000, L"%ws %d %ws %ws", DLL_INJECTOR_PATH32, dwTargetPid, SCYTHE_HOOK_DLL_PATH32, SCYTHE_HOOK_LOG_PATH32);
		}
		else {
			_snwprintf(CommandLine, 1000, L"%ws %d %ws %ws", DLL_INJECTOR_PATH64, dwTargetPid, SCYTHE_HOOK_DLL_PATH64, SCYTHE_HOOK_LOG_PATH64);
		}

		bSuccess = CreateProcessW(nullptr, CommandLine, nullptr, nullptr, false, DETACHED_PROCESS, nullptr, nullptr, &StartupInfo, &ProcessInfo);

		if (bSuccess) {
			CloseHandle(ProcessInfo.hThread);
			CloseHandle(ProcessInfo.hProcess);
		}
	}
	catch (int32_t nError) {
		Intf->Log("... failed to initialize class object for PID %d\r\n", dwTargetPid);
	}

	return bSuccess;
}

int32_t Install(const wstring& DllPath) {
	PROCESSENTRY32W ProcEntry = { 0 };
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	shared_ptr<Interface> Intf = make_shared<Interface>(true, VerbosityLevel::Surface);
	shared_ptr<ApiTable> DynamicApis = make_shared<ApiTable>(Intf);

	if (GrantSelfSeDebug()) {
		Intf->Log("... successfully granted SeDebug privilege to self\r\n");
	}
	else {
		Intf->Log("... failed to grant SeDebug privilege to self\r\n");
	}

	Intf->Log("... enumerating processes for DLL injection of %ws...\r\n", DllPath.c_str());

	if (hSnapshot != INVALID_HANDLE_VALUE) {
		ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

		if (Process32FirstW(hSnapshot, &ProcEntry)) {
			do {
				if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
					try {
						Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID, ProcEntry.szExeFile);
						bool bValidTarget = false;
#ifdef _WIN64
						if (!Ps.IsWow64()) {
							bValidTarget = true;
						}
#else
						if (Ps.IsWow64()) {
							bValidTarget = true;
						}
#endif
						if (bValidTarget) {
							//Ps.Print();
							if (InjectDll(Intf, DynamicApis, Ps.GetHandle(), ProcEntry.th32ProcessID, gSelfModulePath)) {
								Intf->Log("... successfully injected %ws into %ws %d\r\n", gSelfModulePath, Ps.GetName().c_str(), ProcEntry.th32ProcessID);
								//Ps.Print();
							}
							else {
								Intf->Log("... failed to inject %ws into %ws %d\r\n", gSelfModulePath, Ps.GetName().c_str(), ProcEntry.th32ProcessID);
							}
						}
					}
					catch (int32_t nError) {
						Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
					}
				}
			} while (Process32NextW(hSnapshot, &ProcEntry));
		}

		CloseHandle(hSnapshot);
	}
}

class CMyEvent : public IEventCallback
{
public:
	virtual BOOL DoEvent(const CRefPtr<CEventView> pEventView)
	{
		if (pEventView->GetEventClass() == MONITOR_TYPE_PROCESS) {
			/*
			ULONGLONG Time = pEventView->GetStartTime().QuadPart;

			LogMessage(L_INFO, TEXT("%llu Process %s Do 0x%x %s for %s"),
				Time,
				pEventView->GetProcessName().GetBuffer(),
				pEventView->GetEventOperator(),
				StrMapOperation(pEventView->GetPreEventEntry()),
				pEventView->GetPath().GetBuffer());
			*/

			if (pEventView->GetEventOperator() == LOG_PROCESS_NOTIFY_TYPE::NOTIFY_PROCESS_INIT) {
				Intf->Log("... new process creation event: %ws (PID %d) launched from parent %d\r\n", pEventView->GetImagePath().GetBuffer(), pEventView->GetProcessId(), pEventView->GetParentProcessId());

				if (wcsstr(pEventView->GetImagePath().GetBuffer(), L"InjectDLL") == nullptr) {
					if (LaunchDllInjector(pEventView->GetProcessId())) {
						Intf->Log("... successfully executed DLL injector for PID %d\r\n", pEventView->GetProcessId());
					}
					else {
						Intf->Log("... failed to execute DLL injector for PID %d\r\n", pEventView->GetProcessId());
					}
				}
			}
		}
		return TRUE;
	}
};

int32_t InstallOnProcessCreation() {
	CEventMgr& Optmgr = Singleton<CEventMgr>::getInstance();
	CMonitorContoller& Monitormgr = Singleton<CMonitorContoller>::getInstance();
	CDrvLoader& Drvload = Singleton<CDrvLoader>::getInstance();
	Intf = make_shared<Interface>(true, VerbosityLevel::Surface);
	DynamicApis = make_shared<ApiTable>(Intf);

	if (!Drvload.Init(TEXT("PROCMON24"), TEXT("procmon.sys"))) {
		return -1;
	}
	Optmgr.RegisterCallback(new CMyEvent);

	//
	// Try to connect to procmon driver
	//

	if (!Monitormgr.Connect()) {
		LogMessage(L_ERROR, TEXT("Cannot connect to procmon driver"));
		return -1;
	}

	//
	// try to start monitor
	//

	Monitormgr.SetMonitor(TRUE, TRUE, FALSE);
	if (!Monitormgr.Start()) {
		LogMessage(L_ERROR, TEXT("Cannot start the mointor"));
		return -1;
	}

	system("pause");

	//
	// try to stop the monitor
	//

	Monitormgr.Stop();

	LogMessage(L_INFO, TEXT("!!!!!monitor stop press any key to start!!!!"));
	system("pause");

	Monitormgr.Start();

	system("pause");

	Monitormgr.Stop();
	Monitormgr.Destory();
}