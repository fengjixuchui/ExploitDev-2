#include "stdafx.h"

bool InjectDll(const shared_ptr<Interface>& Intf, HANDLE hProcess, uint32_t dwTargetPid, const wchar_t* DllPath) {
	bool bSuccess = false;
	uint32_t dwDllPathBufSize = (wcslen(DllPath) + 1) * 2;
	static HMODULE hKernel32Module = GetModuleHandleA("kernel32.dll");
	static uint8_t* pLoadLibraryWAddress = reinterpret_cast<uint8_t*>(GetProcAddress(hKernel32Module, "LoadLibraryW"));

	uint8_t* pRemoteBuf = static_cast<uint8_t*>(VirtualAllocEx(hProcess, nullptr, dwDllPathBufSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	if (pRemoteBuf != nullptr) {
		if (WriteProcessMemory(hProcess, pRemoteBuf, DllPath, dwDllPathBufSize, nullptr)) {
			if (CreateRemoteThread(hProcess, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pLoadLibraryWAddress), pRemoteBuf, 0, nullptr)) {
				Intf->Log("... successfully created remote thread for DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
				bSuccess = true;
			}
			else {
				Intf->Log("... failed to inject DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
			}
		}
		else {
			Intf->Log("... failed to write path of DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
		}
	}
	else {
		Intf->Log("... failed to allocate memory for DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
	}

	return bSuccess;
}