#include "StdAfx.h"
#include "MinHook.h"
#include "ScytheHookDll.h"

#ifdef _WIN64
#pragma comment(lib, "libMinHook-x64-v142-mt.lib")
#else
#pragma comment(lib, "libMinHook-x86-v142-mt.lib")
#endif

wchar_t gSelfExeName[MAX_PATH + 1] = { 0 };
shared_ptr<Interface> Intf;
NtAllocateVirtualMemory_t gpNtAllocateVirtualMemoryTrampoline = nullptr;
NtMapViewOfSection_t gpNtMapViewOfSectionTrampoline = nullptr;
NtProtectVirtualMemory_t gpNtProtectVirtualMemoryTrampoline = nullptr;
NtCreateProcessEx_t gpNtCreateProcessExTrampoline = nullptr;

bool GetProcessName(uint32_t dwPID, wchar_t* ProcessName, uint32_t ccProcessNameLen) {
    HANDLE hProcess;
    uint32_t dwOutLen = ccProcessNameLen;
    bool bSuccess = false;

    if ((hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwPID)) != NULL) {
        if (QueryFullProcessImageNameW(hProcess, 0, ProcessName, (PDWORD)&dwOutLen)) {
            bSuccess = true;
        }

        CloseHandle(hProcess);
    }

    return bSuccess;
}

NTSTATUS NTAPI DetourNtCreateProcessEx(PHANDLE ProcessHandle, ACCESS_MASK  DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle OPTIONAL, HANDLE DebugPort OPTIONAL, HANDLE ExceptionPort OPTIONAL, BOOLEAN  InJob) {
    wchar_t TargetImageFilePath[MAX_PATH + 1] = { 0 };

    if (ObjectAttributes != nullptr && ObjectAttributes->ObjectName != nullptr) {
        wcsncpy_s(TargetImageFilePath, MAX_PATH + 1, ObjectAttributes->ObjectName->Buffer, ObjectAttributes->ObjectName->Length);
        Intf->Log("%ws(%d) -> launching new process %ws\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath);
    }
    else {
        wcscpy_s(TargetImageFilePath, MAX_PATH + 1, L"?");
    }

    NTSTATUS NtStatus = gpNtCreateProcessExTrampoline(ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, InJob);

    if (NT_SUCCESS(NtStatus)) {
        Intf->Log("%ws(%d) -> successfully launched new process %ws assigned PID %d\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath, GetProcessId(ProcessHandle));
    }
    else {
        Intf->Log("%ws(%d) -> failed to launch new process %ws (error 0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath, NtStatus);
    }

    return NtStatus;
}

NTSTATUS NTAPI DetourNtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, SIZE_T* RegionSize, ULONG NewProtect, PULONG OldProtect) {
    bool bInteresting = false;
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (NewProtect == 0x40 || NewProtect == PAGE_EXECUTE_READ) {
        bInteresting = true;
        Intf->Log("%ws(%d) ->  NtProtectVirtualMemory +X: 0x%x\r\n", gSelfExeName, GetCurrentProcessId(), NewProtect);
    }

    if (bInteresting) {
        if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
            if (dwTargetPid != GetCurrentProcessId()) {
                wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };
                bInteresting = true;
                GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
                Intf->Log("%ws(%d) -> remote NtProtectVirtualMemory to %d (%ws)\r\n", gSelfExeName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
            }
        }
        else {
            Intf->Log("%ws(%d) -> unknown NtProtectVirtualMemory PID associated with handle 0x%p\r\n", gSelfExeName, GetCurrentProcessId(), ProcessHandle);
        }
    }

    NTSTATUS NtStatus = gpNtProtectVirtualMemoryTrampoline(ProcessHandle, BaseAddress, RegionSize, NewProtect, OldProtect);

    return NtStatus;
}

NTSTATUS NTAPI DetourNtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect) {
    bool bInteresting = false;
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (Protect == 0x40) {
        bInteresting = true;
        Intf->Log("%ws(%d) -> NtAllocateVirtualMemory +RWX\r\n", gSelfExeName, GetCurrentProcessId());
    }

    if (bInteresting) {
        if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
            if (dwTargetPid != GetCurrentProcessId()) {
                wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

                bInteresting = true;
                GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
                Intf->Log("%ws(%d) -> remote NtAllocateVirtualMemory to %d (%ws)\r\n", gSelfExeName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
            }
        }
        else {
            Intf->Log("%ws(%d) -> unknown NtAllocateVirtualMemory PID associated with handle 0x%p\r\n", gSelfExeName, GetCurrentProcessId(), ProcessHandle);
        }
    }

    NTSTATUS NtStatus = gpNtAllocateVirtualMemoryTrampoline(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);

    if (bInteresting) {
        Intf->Log("%ws(%d) ->  NtAllocateVirtualMemory (0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), NtStatus);
        Intf->Log("    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log("    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log("    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log("    RegionSize: 0x%p : 0x%08x\r\n", RegionSize, *RegionSize);
        Intf->Log("    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log("    Protect: 0x%08x\r\n", Protect);
        Intf->Log("\r\n\r\n");
    }

    return NtStatus;
}

NTSTATUS NTAPI DetourNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG InheritDisposition, ULONG AllocationType, ULONG Win32Protect) {
    bool bInteresting = false;
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (Win32Protect == 0x40) {
        bInteresting = true;
        Intf->Log("%ws(%d) -> NtMapViewOfSection +RWX section mapping\r\n", gSelfExeName, GetCurrentProcessId());
    }

    if (bInteresting) {
        if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
            if (dwTargetPid != GetCurrentProcessId()) {
                wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

                bInteresting = true;
                GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
                Intf->Log("%ws(%d) -> remote NtMapViewOfSection to %d (%ws)\r\n", gSelfExeName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
            }
        }
        else {
            Intf->Log("%ws(%d) -> unknown NtMapViewOfSection PID associated with handle 0x%p\r\n", gSelfExeName, GetCurrentProcessId(), ProcessHandle);
        }
    }

    NTSTATUS NtStatus = gpNtMapViewOfSectionTrampoline(SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);

    if (bInteresting) {
        Intf->Log("%ws(%d) ->  NtMapViewOfSection (0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), NtStatus);
        Intf->Log("    SectionHandle: 0x%p\r\n", SectionHandle);
        Intf->Log("    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log("    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log("    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log("    CommitSize: 0x%08x\r\n", CommitSize);
        Intf->Log("    SectionOffset: 0x%p\r\n", SectionOffset);
        Intf->Log("    ViewSize: 0x%p : %d\r\n", ViewSize, *ViewSize);
        Intf->Log("    InheritDisposition: 0x%08x\r\n", InheritDisposition);
        Intf->Log("    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log("    Win32Protect: 0x%08x\r\n", Win32Protect);
        Intf->Log("\r\n\r\n");
    }

    return NtStatus;
}
//HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs
uint32_t SetHooks(void* pParam) {
    wchar_t MutexName[500] = { 0 };
    HANDLE hInstallEvent = CreateEventW(nullptr, true, false, INSTALL_EVENT_NAME);

    // The event creation should always be successful: if it didn't exist yet, it creates it in a non-triggered state. If it does, it opens a handle to it.

    if (hInstallEvent != nullptr) {
        WaitForSingleObject(hInstallEvent, INFINITE); // Install export will set this once everything is hooked

        if (!gbInstallerCtx) {
            //Intf = new Interface(L"C:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\ScytheHook\\Release\\\ScytheHook.log");
            Intf = make_shared<Interface>(L"C:\\ProgramData\\ScytheHook.log", false, VerbosityLevel::Surface);
            shared_ptr<ApiTable> DynamicApis = make_shared<ApiTable>(Intf);

            GetModuleFileNameW(nullptr, gSelfExeName, MAX_PATH + 1);
            _snwprintf_s(MutexName, sizeof(MutexName), 500, L"Scythe_%ws_%d", gSelfExeName, GetCurrentProcessId());

            for (int32_t nX = 0; nX < wcslen(MutexName); nX++) {
                if (MutexName[nX] == '\\') {
                    MutexName[nX] = '_'; // \ is an illegal character in named mutexes and causes CreateMutex to fail.
                }
            }

            Intf->Log(VerbosityLevel::Detail, "... obtaining mutex %ws...\r\n", MutexName);

            if (CreateMutexW(nullptr, true, MutexName) != nullptr) {
                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    Intf->Log(VerbosityLevel::Detail, "... setting hooks within %ws (PID %d)...\r\n", gSelfExeName, GetCurrentProcessId());

                    if (MH_Initialize() == MH_OK) {
                        if (MH_CreateHook(DynamicApis->NtMapViewOfSection, &DetourNtMapViewOfSection, reinterpret_cast<LPVOID*>(&gpNtMapViewOfSectionTrampoline)) == MH_OK) {
                            if (MH_EnableHook(DynamicApis->NtMapViewOfSection) == MH_OK) {
                                if (MH_CreateHook(DynamicApis->NtAllocateVirtualMemory, &DetourNtAllocateVirtualMemory, reinterpret_cast<LPVOID*>(&gpNtAllocateVirtualMemoryTrampoline)) == MH_OK) {
                                    if (MH_EnableHook(DynamicApis->NtAllocateVirtualMemory) == MH_OK) {
                                        if (MH_CreateHook(DynamicApis->NtProtectVirtualMemory, &DetourNtProtectVirtualMemory, reinterpret_cast<LPVOID*>(&gpNtProtectVirtualMemoryTrampoline)) == MH_OK) {
                                            if (MH_EnableHook(DynamicApis->NtProtectVirtualMemory) == MH_OK) {
                                                if (MH_CreateHook(DynamicApis->NtCreateProcessEx, &DetourNtCreateProcessEx, reinterpret_cast<LPVOID*>(&gpNtCreateProcessExTrampoline)) == MH_OK) {
                                                    if (MH_EnableHook(DynamicApis->NtCreateProcessEx) == MH_OK) {
                                                        Intf->Log(VerbosityLevel::Detail, "... successfully set and enabled hooks on all target APIs\r\n");
                                                        return 1;
                                                    }
                                                    else {
                                                        Intf->Log("... failed to enable hook on NtCreateProcessEx at 0x%p\r\n", DynamicApis->NtCreateProcessEx);
                                                    }
                                                }
                                                else {
                                                    Intf->Log("... failed to set hook on NtCreateProcessEx at 0x%p\r\n", DynamicApis->NtCreateProcessEx);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                Intf->Log("... failed to enable hook on NtMapViewOfSection at 0x%p\r\n", DynamicApis->NtMapViewOfSection);
                            }
                        }
                        else {
                            Intf->Log("... failed to set hook on NtMapViewOfSection at 0x%p\r\n", DynamicApis->NtMapViewOfSection);
                        }
                    }
                    else {
                        Intf->Log("... failed to initialize Minhook\r\n");
                    }
                }
            }
            else {
                Intf->Log("... failed to create mutex (error 0x%08x)\r\n", GetLastError());
            }

            HANDLE hUninstallEvent = CreateEventW(nullptr, true, false, UNINSTALL_EVENT_NAME);

            // The event creation should always be successful: if it didn't exist yet, it creates it in a non-triggered state. If it does, it opens a handle to it.

            if (hUninstallEvent != nullptr) {
                WaitForSingleObject(hUninstallEvent, INFINITE); // Install export will set this
                Intf->Log("%ws(%d) -> received uninstall event signal\r\n", gSelfExeName, GetCurrentProcessId());
            }
        }
        else {
            Intf->Log("... skipping hooks within installer instance\r\n");
        }
    }
    else {
        Intf->Log("... failed create event %ws (error 0x%08x)\r\n", INSTALL_EVENT_NAME, GetLastError());
    }

    return 0;
}
