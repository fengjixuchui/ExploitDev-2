#include "StdAfx.h"
#include "MinHook.h"
#include "ScytheHookDll.h"

#ifdef _WIN64
#pragma comment(lib, "libMinHook-x64-v142-mt.lib")
#else
#pragma comment(lib, "libMinHook-x86-v142-mt.lib")
#endif

wchar_t gSelfExeName[MAX_PATH + 1] = { 0 };
shared_ptr<Interface> Intf;
shared_ptr<ApiTable> DynamicApis;
NtAllocateVirtualMemory_t gpNtAllocateVirtualMemoryTrampoline = nullptr;
NtMapViewOfSection_t gpNtMapViewOfSectionTrampoline = nullptr;
NtProtectVirtualMemory_t gpNtProtectVirtualMemoryTrampoline = nullptr;
NtCreateProcessEx_t gpNtCreateProcessExTrampoline = nullptr;
NtCreateUserProcess_t gpNtCreateUserProcessTrampoline = nullptr;
VerbosityLevel volatile HookVerbLevel = VerbosityLevel::Debug;
//LONG volatile IsExitProcHooked = 0;

bool GetProcessName(uint32_t dwPID, wchar_t* ProcessName, uint32_t ccProcessNameLen) {
    HANDLE hProcess;
    uint32_t dwOutLen = ccProcessNameLen;
    bool bSuccess = false;

    if ((hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwPID)) != NULL) {
        if (QueryFullProcessImageNameW(hProcess, 0, ProcessName, (PDWORD)&dwOutLen)) {
            bSuccess = true;
        }

        CloseHandle(hProcess);
    }

    return bSuccess;
}

NTSTATUS NTAPI DetourNtCreateProcessEx(PHANDLE ProcessHandle, ACCESS_MASK  DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle OPTIONAL, HANDLE DebugPort OPTIONAL, HANDLE ExceptionPort OPTIONAL, BOOLEAN  InJob) {
    wchar_t TargetImageFilePath[MAX_PATH + 1] = { 0 };

    if (ObjectAttributes != nullptr && ObjectAttributes->ObjectName != nullptr) {
        wcsncpy_s(TargetImageFilePath, MAX_PATH + 1, ObjectAttributes->ObjectName->Buffer, ObjectAttributes->ObjectName->Length);
        Intf->Log(HookVerbLevel, "%ws(%d) -> launching new process %ws\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath);
    }
    else {
        wcscpy_s(TargetImageFilePath, MAX_PATH + 1, L"?");
    }

    NTSTATUS NtStatus = gpNtCreateProcessExTrampoline(ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, InJob);

    if (NT_SUCCESS(NtStatus)) {
        Intf->Log(HookVerbLevel, "%ws(%d) -> successfully launched new process %ws assigned PID %d\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath, GetProcessId(*ProcessHandle));
    }
    else {
        Intf->Log(HookVerbLevel, "%ws(%d) -> failed to launch new process %ws (error 0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath, NtStatus);
    }

    return NtStatus;
}

NTSTATUS NTAPI DetourNtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, SIZE_T* RegionSize, ULONG NewProtect, PULONG OldProtect) {
    bool bInteresting = false;
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (NewProtect == 0x40 || NewProtect == PAGE_EXECUTE_READ) {
        bInteresting = true;
        Intf->Log(HookVerbLevel, "%ws(%d) ->  NtProtectVirtualMemory +X: 0x%x\r\n", gSelfExeName, GetCurrentProcessId(), NewProtect);
    }

    if (bInteresting) {
        if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
            if (dwTargetPid != GetCurrentProcessId()) {
                wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };
                bInteresting = true;
                GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
                Intf->Log(HookVerbLevel, "%ws(%d) -> remote NtProtectVirtualMemory to %d (%ws)\r\n", gSelfExeName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
            }
        }
        else {
            Intf->Log(HookVerbLevel, "%ws(%d) -> unknown NtProtectVirtualMemory PID associated with handle 0x%p\r\n", gSelfExeName, GetCurrentProcessId(), ProcessHandle);
        }
    }

    NTSTATUS NtStatus = gpNtProtectVirtualMemoryTrampoline(ProcessHandle, BaseAddress, RegionSize, NewProtect, OldProtect);

    return NtStatus;
}

NTSTATUS NTAPI DetourNtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect) {
    bool bInteresting = false;
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (Protect == 0x40) {
        bInteresting = true;
        Intf->Log(HookVerbLevel, "%ws(%d) -> NtAllocateVirtualMemory +RWX\r\n", gSelfExeName, GetCurrentProcessId());
    }

    if (bInteresting) {
        if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
            if (dwTargetPid != GetCurrentProcessId()) {
                wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

                bInteresting = true;
                GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
                Intf->Log(HookVerbLevel, "%ws(%d) -> remote NtAllocateVirtualMemory to %d (%ws)\r\n", gSelfExeName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
            }
        }
        else {
            Intf->Log(HookVerbLevel, "%ws(%d) -> unknown NtAllocateVirtualMemory PID associated with handle 0x%p\r\n", gSelfExeName, GetCurrentProcessId(), ProcessHandle);
        }
    }

    NTSTATUS NtStatus = gpNtAllocateVirtualMemoryTrampoline(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);

    if (bInteresting) {
        Intf->Log(HookVerbLevel, "%ws(%d) ->  NtAllocateVirtualMemory (0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), NtStatus);
        Intf->Log(HookVerbLevel, "    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log(HookVerbLevel, "    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log(HookVerbLevel, "    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log(HookVerbLevel, "    RegionSize: 0x%p : 0x%08x\r\n", RegionSize, *RegionSize);
        Intf->Log(HookVerbLevel, "    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log(HookVerbLevel, "    Protect: 0x%08x\r\n", Protect);
        Intf->Log(HookVerbLevel, "\r\n\r\n");
    }

    return NtStatus;
}

NTSTATUS NTAPI DetourNtCreateUserProcess(PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess, ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes, POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ProcessFlags, ULONG ThreadFlags, PRTL_USER_PROCESS_PARAMETERS ProcessParameters, void* CreateInfo, void* AttributeList) {
    wchar_t TargetImageFilePath[MAX_PATH + 1] = { 0 };

    if (ProcessParameters != nullptr && ProcessParameters->ImagePathName.Length) {
        wcsncpy_s(TargetImageFilePath, MAX_PATH + 1, ProcessParameters->ImagePathName.Buffer, ProcessParameters->ImagePathName.Length);
    }
    else {
        wcscpy_s(TargetImageFilePath, MAX_PATH + 1, L"?");
    }

    Intf->Log(HookVerbLevel, "%ws(%d) -> launching new process %ws\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath);

    NTSTATUS NtStatus = gpNtCreateUserProcessTrampoline(ProcessHandle, ThreadHandle, ProcessDesiredAccess, ThreadDesiredAccess, ProcessObjectAttributes, ThreadObjectAttributes, ProcessFlags, ThreadFlags, ProcessParameters, CreateInfo, AttributeList);

    if (NT_SUCCESS(NtStatus)) {
        uint32_t dwCreatedPid = GetProcessId(*ProcessHandle);
        BOOL bWow64 = FALSE;

        Intf->Log(HookVerbLevel, "%ws(%d) -> successfully launched new process %ws assigned PID %d\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath, dwCreatedPid);
        
        if (DynamicApis->IsWow64Process(*ProcessHandle, &bWow64)) {
#ifdef _WIN64
            if (!bWow64) {
#else
            if (bWow64) {
#endif
                if (InjectDll(Intf, DynamicApis, *ProcessHandle, dwCreatedPid, gSelfModulePath)) {
                    Intf->Log(HookVerbLevel, "%ws(%d) -> successfully injected self at %ws into new PID %d\r\n", gSelfExeName, GetCurrentProcessId(), gSelfModulePath, dwCreatedPid);
                }
                else {
                    Intf->Log(HookVerbLevel, "%ws(%d) -> failed to inject self at %ws into new PID %d\r\n", gSelfExeName, GetCurrentProcessId(), gSelfModulePath, dwCreatedPid);
                }
            }
            else {
                Intf->Log(HookVerbLevel, "%ws(%d) -> mismatching 32/64 architecture to inject self at %ws into new PID %d\r\n", gSelfExeName, GetCurrentProcessId(), gSelfModulePath, dwCreatedPid);
            }
        }
        else {
            Intf->Log(HookVerbLevel, "%ws(%d) -> failed to query Wow64 to check 32/64 architecture to inject self at %ws into new PID %d\r\n", gSelfExeName, GetCurrentProcessId(), gSelfModulePath, dwCreatedPid);
        }
    }
    else {
        Intf->Log(HookVerbLevel, "%ws(%d) -> failed to launch new process %ws (error 0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), TargetImageFilePath, NtStatus);
    }

    return NtStatus;
}

NTSTATUS NTAPI DetourNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG InheritDisposition, ULONG AllocationType, ULONG Win32Protect) {
    bool bInteresting = false;
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (Win32Protect == 0x40) {
        bInteresting = true;
        Intf->Log(HookVerbLevel, "%ws(%d) -> NtMapViewOfSection +RWX section mapping\r\n", gSelfExeName, GetCurrentProcessId());
    }

    if (bInteresting) {
        if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
            if (dwTargetPid != GetCurrentProcessId()) {
                wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

                bInteresting = true;
                GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
                Intf->Log(HookVerbLevel, "%ws(%d) -> remote NtMapViewOfSection to %d (%ws)\r\n", gSelfExeName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
            }
        }
        else {
            Intf->Log(HookVerbLevel, "%ws(%d) -> unknown NtMapViewOfSection PID associated with handle 0x%p\r\n", gSelfExeName, GetCurrentProcessId(), ProcessHandle);
        }
    }

    NTSTATUS NtStatus = gpNtMapViewOfSectionTrampoline(SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);

    if (bInteresting) {
        Intf->Log(HookVerbLevel, "%ws(%d) ->  NtMapViewOfSection (0x%08x)\r\n", gSelfExeName, GetCurrentProcessId(), NtStatus);
        Intf->Log(HookVerbLevel, "    SectionHandle: 0x%p\r\n", SectionHandle);
        Intf->Log(HookVerbLevel, "    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log(HookVerbLevel, "    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log(HookVerbLevel, "    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log(HookVerbLevel, "    CommitSize: 0x%08x\r\n", CommitSize);
        Intf->Log(HookVerbLevel, "    SectionOffset: 0x%p\r\n", SectionOffset);
        Intf->Log(HookVerbLevel, "    ViewSize: 0x%p : %d\r\n", ViewSize, *ViewSize);
        Intf->Log(HookVerbLevel, "    InheritDisposition: 0x%08x\r\n", InheritDisposition);
        Intf->Log(HookVerbLevel, "    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log(HookVerbLevel, "    Win32Protect: 0x%08x\r\n", Win32Protect);
        Intf->Log(HookVerbLevel, "\r\n\r\n");
    }

    return NtStatus;
}
//HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs
uint32_t SetHooks(void* pParam) {
    wchar_t MutexName[500] = { 0 };

    // There's a quirk/race condition here: we don't want any of this code to run if this is an installer instance, but it will.
    // Before the 

    if (wcsstr(GetCommandLineW(), L".dll,Install") == nullptr && wcsstr(GetCommandLineW(), L"undll32") == nullptr) {
        HANDLE hInstallEvent = CreateEventW(nullptr, true, false, INSTALL_EVENT_NAME);

        if (hInstallEvent != nullptr) {
            WaitForSingleObject(hInstallEvent, INFINITE); // Install export will set this once everything is hooked
            CloseHandle(hInstallEvent);
            //Intf = new Interface(L"C:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\ScytheHook\\Release\\\ScytheHook.log");
            Intf = make_shared<Interface>(SCYTHE_HOOK_LOG_FILE_PATH, false, VerbosityLevel::Surface);
            DynamicApis = make_shared<ApiTable>(Intf);
            HANDLE hMutex;

            GetModuleBaseNameW(GetCurrentProcess(), nullptr, gSelfExeName, MAX_PATH + 1);
#ifdef _WIN64
            _snwprintf_s(MutexName, sizeof(MutexName), 500, L"Global\\Scythe64_%ws_%d", gSelfExeName, GetCurrentProcessId());
#else
            _snwprintf_s(MutexName, sizeof(MutexName), 500, L"Global\\Scythe32_%ws_%d", gSelfExeName, GetCurrentProcessId());
#endif
            /*
            for (int32_t nX = 0; nX < wcslen(MutexName); nX++) {
                if (MutexName[nX] == '\\') {
                    MutexName[nX] = '_'; // \ is an illegal character in named mutexes and causes CreateMutex to fail.
                }
            }*/

            Intf->Log(VerbosityLevel::Detail, "... obtaining mutex %ws...\r\n", MutexName);

            if ((hMutex = CreateMutexW(nullptr, true, MutexName)) != nullptr) {
                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    bool bHooked = false;

                    Intf->Log(VerbosityLevel::Detail, "... setting hooks within %ws (PID %d)...\r\n", gSelfExeName, GetCurrentProcessId());

                    if (MH_Initialize() == MH_OK) {
                        if (MH_CreateHook(DynamicApis->NtMapViewOfSection, &DetourNtMapViewOfSection, reinterpret_cast<LPVOID*>(&gpNtMapViewOfSectionTrampoline)) == MH_OK) {
                            if (MH_EnableHook(DynamicApis->NtMapViewOfSection) == MH_OK) {
                                if (MH_CreateHook(DynamicApis->NtAllocateVirtualMemory, &DetourNtAllocateVirtualMemory, reinterpret_cast<LPVOID*>(&gpNtAllocateVirtualMemoryTrampoline)) == MH_OK) {
                                    if (MH_EnableHook(DynamicApis->NtAllocateVirtualMemory) == MH_OK) {
                                        if (MH_CreateHook(DynamicApis->NtProtectVirtualMemory, &DetourNtProtectVirtualMemory, reinterpret_cast<LPVOID*>(&gpNtProtectVirtualMemoryTrampoline)) == MH_OK) {
                                            if (MH_EnableHook(DynamicApis->NtProtectVirtualMemory) == MH_OK) {
                                                if (MH_CreateHook(DynamicApis->NtCreateProcessEx, &DetourNtCreateProcessEx, reinterpret_cast<LPVOID*>(&gpNtCreateProcessExTrampoline)) == MH_OK) {
                                                    if (MH_EnableHook(DynamicApis->NtCreateProcessEx) == MH_OK) {
                                                        if (MH_CreateHook(DynamicApis->NtCreateUserProcess, &DetourNtCreateUserProcess, reinterpret_cast<LPVOID*>(&gpNtCreateUserProcessTrampoline)) == MH_OK) {
                                                            if (MH_EnableHook(DynamicApis->NtCreateUserProcess) == MH_OK) {
                                                                Intf->Log(VerbosityLevel::Detail, "... successfully set and enabled hooks on all target APIs\r\n");
                                                                //HookVerbLevel = VerbosityLevel::Surface;
                                                                InterlockedExchange(reinterpret_cast<volatile LONG *>(&HookVerbLevel), (LONG)VerbosityLevel::Surface);
                                                                bHooked = true;
                                                                //return 1;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        Intf->Log("... failed to enable hook on NtCreateProcessEx at 0x%p\r\n", DynamicApis->NtCreateProcessEx);
                                                    }
                                                }
                                                else {
                                                    Intf->Log("... failed to set hook on NtCreateProcessEx at 0x%p\r\n", DynamicApis->NtCreateProcessEx);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                Intf->Log("... failed to enable hook on NtMapViewOfSection at 0x%p\r\n", DynamicApis->NtMapViewOfSection);
                            }
                        }
                        else {
                            Intf->Log("... failed to set hook on NtMapViewOfSection at 0x%p\r\n", DynamicApis->NtMapViewOfSection);
                        }
                    }
                    else {
                        Intf->Log("... failed to initialize Minhook\r\n");
                    }

                    if (bHooked) {
                        Intf->Log("%ws(%d) -> unique new process launched and hooked\r\n", gSelfExeName, GetCurrentProcessId());
                    }
                    else {
                        Intf->Log("%ws(%d) -> failed to hook unique new process\r\n", gSelfExeName, GetCurrentProcessId());
                    }
                }

                HANDLE hUninstallEvent = OpenEventW(SYNCHRONIZE, false, UNINSTALL_EVENT_NAME);

                // The event creation should always be successful: if it didn't exist yet, it creates it in a non-triggered state. If it does, it opens a handle to it.

                if (hUninstallEvent != nullptr) {
                    WaitForSingleObject(hUninstallEvent, INFINITE); // Install export will set this
                    Intf->Log("%ws(%d) -> received uninstall event signal\r\n", gSelfExeName, GetCurrentProcessId());
                    CloseHandle(hMutex);
                    CloseHandle(hUninstallEvent);
                }
                else {
                    Intf->Log("%ws(%d) -> failed to open uninstall event\r\n", gSelfExeName, GetCurrentProcessId());
                }
            }
            else {
                Intf->Log("... failed to create mutex (error 0x%08x)\r\n", GetLastError());
            }
        }
    }
    else {
        //Intf->Log("... skipping hooks within installer instance\r\n");
        //MessageBoxA(nullptr, "skipping", GetCommandLineA(), 0);
    }

    return 0;
}
