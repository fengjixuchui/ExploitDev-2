#include "stdafx.h"
#include "ScytheHookDll.h"

BOOL gbInstallerCtx = FALSE;

extern "C" __declspec(dllexport) void Install() {
	AllocConsole();
	freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
	PROCESSENTRY32W ProcEntry = { 0 };
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	shared_ptr<Interface> Intf = make_shared<Interface>(true, VerbosityLevel::Surface);
	shared_ptr<ApiTable> DynamicApis = make_shared<ApiTable>(Intf);

	gbInstallerCtx = TRUE;

	HANDLE hInstallEvent = CreateEventW(nullptr, true, false, INSTALL_EVENT_NAME);

	if (hInstallEvent != nullptr) {
		if (GetLastError() == ERROR_ALREADY_EXISTS) {
			//Intf->Log("... scythe hook install event %ws already exists. This system has already been hooked!\r\n", INSTALL_EVENT_NAME);
		}

		if (GrantSelfSeDebug()) {
			Intf->Log("... successfully granted SeDebug privilege to self\r\n");
		}
		else {
			Intf->Log("... failed to grant SeDebug privilege to self\r\n");
		}

		Intf->Log("... enumerating processes for DLL injection of %ws...\r\n", gSelfModulePath);

		if (hSnapshot != INVALID_HANDLE_VALUE) {
			ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

			if (Process32FirstW(hSnapshot, &ProcEntry)) {
				do {
					if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
						try {
							Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID);
							bool bValidTarget = false;
#ifdef _WIN64
							if (!Ps.IsWow64()) {
								bValidTarget = true;
							}
#else
							if (Ps.IsWow64()) {
								bValidTarget = true;
							}
#endif
							if (bValidTarget) {
								//Ps.Print();
								if (InjectDll(Intf, Ps.GetHandle(), ProcEntry.th32ProcessID, gSelfModulePath)) {
									Intf->Log("... successfully injected %ws into %d\r\n", gSelfModulePath, ProcEntry.th32ProcessID);
									Ps.Print();
								}
								else {
									Intf->Log("... failed to inject %ws into %d\r\n", gSelfModulePath, ProcEntry.th32ProcessID);
								}
							}
						}
						catch (int32_t nError) {
							Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
						}
					}
				} while (Process32NextW(hSnapshot, &ProcEntry));
			}

			CloseHandle(hSnapshot);
		}

		Intf->Log("... setting system-wide install event - this will cause all injected hooking threads to install their hooks and begin logging.\r\n");
		SetEvent(hInstallEvent);
		system("pause");

		HANDLE hUninstallEvent = CreateEventW(nullptr, true, false, UNINSTALL_EVENT_NAME);

		// The event creation should always be successful: if it didn't exist yet, it creates it in a non-triggered state. If it does, it opens a handle to it.

		if (hUninstallEvent != nullptr) {
			Intf->Log("... setting system-wide uninstall event\r\n");
			SetEvent(hUninstallEvent);
		}
	}
}