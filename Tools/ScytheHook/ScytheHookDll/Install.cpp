#include "stdafx.h"
#include "ScytheHookDll.h"

BOOL gbInstallerCtx = FALSE;

bool InjectDll(const shared_ptr<Interface> &Intf, uint32_t dwTargetPid, const wchar_t *DllPath) {
	HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, false, dwTargetPid);
	bool bSuccess = false;
	uint32_t dwDllPathBufSize = (wcslen(DllPath) + 1) * 2;
	static HMODULE hKernel32Module = GetModuleHandleA("kernel32.dll");
	static uint8_t* pLoadLibraryWAddress = reinterpret_cast<uint8_t *>(GetProcAddress(hKernel32Module, "LoadLibraryW"));

	if (hProcess != nullptr) {
		uint8_t* pRemoteBuf = static_cast<uint8_t *>(VirtualAllocEx(hProcess, nullptr, dwDllPathBufSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

		if (pRemoteBuf != nullptr) {
			if (WriteProcessMemory(hProcess, pRemoteBuf, DllPath, dwDllPathBufSize, nullptr)) {
				if (CreateRemoteThread(hProcess, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pLoadLibraryWAddress), pRemoteBuf, 0, nullptr)) {
					Intf->Log("... successfully created remote thread for DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
					bSuccess = true;
				}
				else {
					Intf->Log("... failed to inject DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
				}
			}
			else {
				Intf->Log("... failed to write path of DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
			}
		}
		else {
			Intf->Log("... failed to allocate memory for DLL %ws into remote PID %d\r\n", DllPath, dwTargetPid);
		}

		CloseHandle(hProcess);
	}
	else {
		Intf->Log("... failed to open handle for DLL %ws injection into remote PID %d\r\n", DllPath, dwTargetPid);
	}

	return bSuccess;
}

extern "C" __declspec(dllexport) void Install() {
	PROCESSENTRY32W ProcEntry = { 0 };
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	shared_ptr<Interface> Intf = make_shared<Interface>(true);
	wchar_t SelfModulePath[MAX_PATH + 1] = { 0 };
	shared_ptr<ApiTable> DynamicApis = make_shared<ApiTable>(Intf);

	//AllocConsole();
	//freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
	gbInstallerCtx = TRUE;

	if (GrantSelfSeDebug()) {
		Intf->Log("... successfully granted SeDebug privilege to self\r\n");
	}
	else {
		Intf->Log("... failed to grant SeDebug privilege to self\r\n");
	}

	GetModuleFileNameW(ghInstance, SelfModulePath, MAX_PATH + 1);

	Intf->Log("... enumerating processes for DLL injection of %ws...\r\n", SelfModulePath);

	if (hSnapshot != nullptr) {
		ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

		if (Process32FirstW(hSnapshot, &ProcEntry)) {
			do {
				if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
					try {
						Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID);
						bool bValidTarget = false;
#ifdef _WIN64
						if (!Ps.IsWow64()) {
							bValidTarget = true;
						}
#else
						if (Ps.IsWow64()) {
							bValidTarget = true;
						}
#endif
						if (bValidTarget) {
							//Ps.Print();
							if (InjectDll(Intf, ProcEntry.th32ProcessID, SelfModulePath)) {
								Intf->Log("... successfully injected %ws into %d\r\n", SelfModulePath, ProcEntry.th32ProcessID);
								Ps.Print();
							}
							else {
								Intf->Log("... failed to inject %ws into %d\r\n", SelfModulePath, ProcEntry.th32ProcessID);
							}
						}
					}
					catch (int32_t nError) {
						Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
					}
				}
			} while (Process32NextW(hSnapshot, &ProcEntry));
		}

		CloseHandle(hSnapshot);
	}

	HANDLE hInstallEvent = CreateEventW(nullptr, true, false, INSTALL_EVENT_NAME);

	if (hInstallEvent != nullptr) {
		if (GetLastError() == ERROR_ALREADY_EXISTS) {
			Intf->Log("... scythe hook install event %ws already exists. This system has already been hooked!\r\n", INSTALL_EVENT_NAME);
		}
		//else {
			Intf->Log("... setting system-wide install event - this will cause all injected hooking threads to install their hooks and begin logging.\r\n");
			SetEvent(hInstallEvent);
		//}
	}

	system("pause");

	HANDLE hUninstallEvent = CreateEventW(nullptr, true, false, UNINSTALL_EVENT_NAME);

	// The event creation should always be successful: if it didn't exist yet, it creates it in a non-triggered state. If it does, it opens a handle to it.

	if (hUninstallEvent != nullptr) {
		Intf->Log("... setting system-wide uninstall event\r\n");
		SetEvent(hUninstallEvent);
	}
}