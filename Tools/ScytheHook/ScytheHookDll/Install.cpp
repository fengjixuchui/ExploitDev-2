#include "stdafx.h"
#include "ScytheHookDll.h"

BOOL gbInstallerCtx = FALSE;

extern "C" __declspec(dllexport) void Install() {
	AllocConsole();
	freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
	PROCESSENTRY32W ProcEntry = { 0 };
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	shared_ptr<Interface> Intf = make_shared<Interface>(true, VerbosityLevel::Surface);
	shared_ptr<ApiTable> DynamicApis = make_shared<ApiTable>(Intf);

	gbInstallerCtx = TRUE;

	HANDLE hInstallEvent = CreateEventW(nullptr, true, false, INSTALL_EVENT_NAME);

	if (hInstallEvent != nullptr) {
		if (GetLastError() == ERROR_ALREADY_EXISTS) {
			//Intf->Log("... scythe hook install event %ws already exists. This system has already been hooked!\r\n", INSTALL_EVENT_NAME);
		}

		if (GrantSelfSeDebug()) {
			Intf->Log("... successfully granted SeDebug privilege to self\r\n");
		}
		else {
			Intf->Log("... failed to grant SeDebug privilege to self\r\n");
		}

		Intf->Log("... enumerating processes for DLL injection of %ws...\r\n", gSelfModulePath);

		if (hSnapshot != INVALID_HANDLE_VALUE) {
			ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

			if (Process32FirstW(hSnapshot, &ProcEntry)) {
				do {
					if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
						try {
							Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID);
							bool bValidTarget = false;
#ifdef _WIN64
							if (!Ps.IsWow64()) {
								bValidTarget = true;
							}
#else
							if (Ps.IsWow64()) {
								bValidTarget = true;
							}
#endif
							if (bValidTarget) {
								//Ps.Print();
								if (InjectDll(Intf, Ps.GetHandle(), ProcEntry.th32ProcessID, gSelfModulePath)) {
									Intf->Log("... successfully injected %ws into %d\r\n", gSelfModulePath, ProcEntry.th32ProcessID);
									//Ps.Print();
								}
								else {
									Intf->Log("... failed to inject %ws into %d\r\n", gSelfModulePath, ProcEntry.th32ProcessID);
								}
							}
						}
						catch (int32_t nError) {
							Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
						}
					}
				} while (Process32NextW(hSnapshot, &ProcEntry));
			}

			CloseHandle(hSnapshot);
		}

		Intf->Log("... setting system-wide install event - this will cause all injected hooking threads to install their hooks and begin logging.\r\n");
		SetEvent(hInstallEvent);
		//system("pause");

		do {
			hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

			if (hSnapshot != INVALID_HANDLE_VALUE) {
				ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

				if (Process32FirstW(hSnapshot, &ProcEntry)) {
					do {
						if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
							try {
								Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID);
								wchar_t MutexName[500] = { 0 };
								HANDLE hMutex;

								_snwprintf_s(MutexName, sizeof(MutexName), 500, L"Global\\Scythe_%ws_%d", Ps.GetName().c_str(), ProcEntry.th32ProcessID);

								if ((hMutex = OpenMutexW(SYNCHRONIZE, false, MutexName)) != nullptr) {
									Intf->Log("... process %ws (PID %d) is still active. Mutex %ws exists\r\n", Ps.GetName().c_str(), ProcEntry.th32ProcessID, MutexName);
									CloseHandle(hMutex);
								}
							}
							catch (int32_t nError) {
								//Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
							}
						}
					} while (Process32NextW(hSnapshot, &ProcEntry));
				}

				CloseHandle(hSnapshot);
			}

			char Input[10] = { 0 };
			Intf->Log("... refresh process list? [1] or uninstall? [2]\r\n");
			gets_s(Input, sizeof(Input));
			if (Input[0] == '1') {
				continue;
			}
			if (Input[0] == '2') {
				HANDLE hUninstallEvent = CreateEventW(nullptr, true, false, UNINSTALL_EVENT_NAME);

				// The event creation should always be successful: if it didn't exist yet, it creates it in a non-triggered state. If it does, it opens a handle to it.

				if (hUninstallEvent != nullptr) {
					Intf->Log("... setting system-wide uninstall event\r\n");
					SetEvent(hUninstallEvent);
				}
			}

		} while (true);
	}
}