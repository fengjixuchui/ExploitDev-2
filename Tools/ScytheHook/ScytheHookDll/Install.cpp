#include "stdafx.h"
#include "ScytheHookDll.h"

BOOL gbInstallerCtx = FALSE;

extern "C" __declspec(dllexport) void Install() {
	AllocConsole();
	freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
	freopen_s((FILE**)stdout, "CONOUT$", "w", stderr);
	freopen_s((FILE**)stdin, "CONIN$", "r", stdin);
	//freopen("CONIN$", "r", stdin);
	//freopen("CONOUT$", "w", stdout);
	//freopen("CONOUT$", "w", stderr);
	PROCESSENTRY32W ProcEntry = { 0 };
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	shared_ptr<Interface> Intf = make_shared<Interface>(true, VerbosityLevel::Surface);
	shared_ptr<ApiTable> DynamicApis = make_shared<ApiTable>(Intf);

	gbInstallerCtx = TRUE;

	HANDLE hInstallEvent = CreateEventW(nullptr, true, false, INSTALL_EVENT_NAME);
	HANDLE hUninstallEvent = CreateEventW(nullptr, true, false, UNINSTALL_EVENT_NAME);

	if (hInstallEvent != nullptr && hUninstallEvent != nullptr) {
		if (GetLastError() == ERROR_ALREADY_EXISTS) {
			//Intf->Log("... scythe hook install event %ws already exists. This system has already been hooked!\r\n", INSTALL_EVENT_NAME);
		}

		if (GrantSelfSeDebug()) {
			Intf->Log("... successfully granted SeDebug privilege to self\r\n");
		}
		else {
			Intf->Log("... failed to grant SeDebug privilege to self\r\n");
		}

		Intf->Log("... enumerating processes for DLL injection of %ws...\r\n", gSelfModulePath);

		if (hSnapshot != INVALID_HANDLE_VALUE) {
			ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

			if (Process32FirstW(hSnapshot, &ProcEntry)) {
				do {
					if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
						try {
							Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID);
							bool bValidTarget = false;
#ifdef _WIN64
							if (!Ps.IsWow64()) {
								bValidTarget = true;
							}
#else
							if (Ps.IsWow64()) {
								bValidTarget = true;
							}
#endif
							if (bValidTarget) {
								//Ps.Print();
								if (InjectDll(Intf, Ps.GetHandle(), ProcEntry.th32ProcessID, gSelfModulePath)) {
									Intf->Log("... successfully injected %ws into %ws %d\r\n", gSelfModulePath, Ps.GetName().c_str(), ProcEntry.th32ProcessID);
									//Ps.Print();
								}
								else {
									Intf->Log("... failed to inject %ws into %ws %d\r\n", gSelfModulePath, Ps.GetName().c_str(), ProcEntry.th32ProcessID);
								}
							}
						}
						catch (int32_t nError) {
							Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
						}
					}
				} while (Process32NextW(hSnapshot, &ProcEntry));
			}

			CloseHandle(hSnapshot);
		}

		Intf->Log("... setting system-wide install event - this will cause all injected hooking threads to install their hooks and begin logging.\r\n");
		getchar();
		SetEvent(hInstallEvent);
		//system("pause");

		while(true) {
			hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

			if (hSnapshot != INVALID_HANDLE_VALUE) {
				ZeroMemory(&ProcEntry, sizeof(ProcEntry));
				ProcEntry.dwSize = sizeof(PROCESSENTRY32W);

				if (Process32FirstW(hSnapshot, &ProcEntry)) {
					do {
						if (ProcEntry.th32ProcessID != GetCurrentProcessId()) {
							try {
								Process Ps(Intf, DynamicApis, ProcEntry.th32ProcessID);
								wchar_t MutexName[500] = { 0 };
								HANDLE hMutex;
								bool bValidTarget = false;
#ifdef _WIN64
								if (!Ps.IsWow64()) {
									bValidTarget = true;
								}
#else
								if (Ps.IsWow64()) {
									bValidTarget = true;
								}
#endif
								if (bValidTarget) {
#ifdef _WIN64
									_snwprintf_s(MutexName, sizeof(MutexName), 500, L"Global\\Scythe64_%ws_%d", Ps.GetName().c_str(), ProcEntry.th32ProcessID);
#else
									_snwprintf_s(MutexName, sizeof(MutexName), 500, L"Global\\Scythe32_%ws_%d", Ps.GetName().c_str(), ProcEntry.th32ProcessID);
#endif
									if ((hMutex = OpenMutexW(SYNCHRONIZE, false, MutexName)) != nullptr) {
										Intf->Log("... process %ws (PID %d) is still active.\r\n", Ps.GetName().c_str(), ProcEntry.th32ProcessID);
										CloseHandle(hMutex);
									}
								}
							}
							catch (int32_t nError) {
								//Intf->Log("... failed to initialize class object for PID %d\r\n", ProcEntry.th32ProcessID);
							}
						}
					} while (Process32NextW(hSnapshot, &ProcEntry));
				}

				CloseHandle(hSnapshot);
			}

			char Input[10] = { 0 };
			Intf->Log("... refresh process list? [1] or uninstall? [2] exit? [3]\r\n");
			gets_s(Input, sizeof(Input));
			if (Input[0] == '1') {
				continue;
			}
			else if (Input[0] == '3') {
				break;
			}
			else if (Input[0] == '2') {
					Intf->Log("... setting system-wide uninstall event\r\n");
					SetEvent(hUninstallEvent);
				
			}

		}

		CloseHandle(hInstallEvent);
	}
}