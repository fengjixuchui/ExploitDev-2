#include "StdAfx.h"
#include "MinHook.h"

using namespace std;

#if defined _M_X64
#pragma comment(lib, "libMinHook.x64.lib")
#elif defined _M_IX86
#pragma comment(lib, "libMinHook-x86-v142-mt.lib")
#endif

typedef NTSTATUS (NTAPI *NtMapViewOfSection_t)(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG InheritDisposition, ULONG AllocationType, ULONG Win32Protect);

typedef int (WINAPI* MESSAGEBOXW)(HWND, LPCWSTR, LPCWSTR, UINT);
//typedef LONG(NTAPI* NtMapViewOfSection_t)(HANDLE, HANDLE, PVOID*, ULONG_PTR, SIZE_T, PLARGE_INTEGER, PSIZE_T, DWORD, ULONG, ULONG);

Interface *Intf;
NtMapViewOfSection_t gpNtMapViewOfSectionTrampoline = nullptr;

bool GetProcessName(uint32_t dwPID, wchar_t *ProcessName, uint32_t ccProcessNameLen) {
    HANDLE hProcess;
    uint32_t dwOutLen = ccProcessNameLen;
    bool bSuccess = false;

    if ((hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwPID)) != NULL) {
        if (QueryFullProcessImageNameW(hProcess, 0, ProcessName, (PDWORD)&dwOutLen)) {
            bSuccess = true;
        }

        CloseHandle(hProcess);
    }

    return bSuccess;
}

NTSTATUS NTAPI DetourNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG InheritDisposition, ULONG AllocationType, ULONG Win32Protect) {
    bool bInteresting = false;
    wchar_t CurrentProcessName[MAX_PATH + 1] = { 0 };
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    //MessageBoxW(NULL, L"DetourNtMapViewOfSection", L"", 0);
    if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
        if (dwTargetPid != GetCurrentProcessId()) {
            wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

            GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
            bInteresting = true;
            GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
            Intf->Log("[%ws : %d] Remote NtMapViewOfSection to %d (%ws)\r\n", CurrentProcessName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
        }
    }
    else {
        GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
        Intf->Log("[%ws : %d] Unknown PID associated with handle 0x%p\r\n", CurrentProcessName, GetCurrentProcessId(), ProcessHandle);
    }

    if (Win32Protect == 0x40) {
        bInteresting = true;
        Intf->Log("[%ws : %d] +RWX section mapping\r\n", CurrentProcessName, GetCurrentProcessId());
    }

    NTSTATUS NtStatus = gpNtMapViewOfSectionTrampoline(SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);

    if (bInteresting) {
        Intf->Log("\r\n... NtMapViewOfSection called with parameters:\r\n");
        Intf->Log("    SectionHandle: 0x%p\r\n", SectionHandle);
        Intf->Log("    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log("    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log("    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log("    CommitSize: 0x%08x\r\n", CommitSize);
        Intf->Log("    SectionOffset: 0x%p\r\n", SectionOffset);
        Intf->Log("    ViewSize: 0x%p : %d\r\n", ViewSize, *ViewSize);
        Intf->Log("    InheritDisposition: 0x%08x\r\n", InheritDisposition);
        Intf->Log("    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log("    Win32Protect: 0x%08x\r\n", Win32Protect);
        Intf->Log("\r\n\r\n");
    }

    return NtStatus;
}

bool SetHooks() {
    HMODULE hNtdllModule = GetModuleHandleW(L"ntdll.dll");
    NtMapViewOfSection_t NtMapViewOfSection = (NtMapViewOfSection_t)GetProcAddress(hNtdllModule, "NtMapViewOfSection");
    wchar_t CurrentProcessName[MAX_PATH + 1] = { 0 };

    Intf = new Interface(L"C:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\ScytheHook\\Release\\\ScytheHook.log");
    GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);

    Intf->Log("... setting hooks within %ws (PID %d)...\r\n", CurrentProcessName, GetCurrentProcessId());

    if (MH_Initialize() == MH_OK)
    {

        //gpOriginalNtMapViewOfSection = (NtMapViewOfSection_t)GetProcAddress(hNtdllModule, "NtMapViewOfSection");

        // or you can use the new helper function like this.
        /*
        if (MH_CreateHookApiEx(L"ntdll.dll", "NtMapViewOfSection", &DetourNtMapViewOfSection, reinterpret_cast<void**>(&gpOriginalNtMapViewOfSection), nullptr) != MH_OK)
        {
            return 1;
        }*/

        if (MH_CreateHook(NtMapViewOfSection, &DetourNtMapViewOfSection,
            reinterpret_cast<LPVOID*>(&gpNtMapViewOfSectionTrampoline)) == MH_OK)
        {

            // Enable the hook for MessageBoxW.
            if (MH_EnableHook(NtMapViewOfSection) == MH_OK)
            {

                Intf->Log("... successfully set and enabled hook on NtMapViewOfSection at 0x%p\r\n", NtMapViewOfSection);
                /*
                if (MH_DisableHook(NtMapViewOfSection) != MH_OK)
                {
                    return 1;
                }*/

                return true;
            }
            else {
                Intf->Log("... failed to enable hook on NtMapViewOfSection at 0x%p\r\n", NtMapViewOfSection);
            }
        }
        else {
            Intf->Log("... failed to set hook on NtMapViewOfSection at 0x%p\r\n", NtMapViewOfSection);
        }
        /*
        // Uninitialize MinHook.
        if (MH_Uninitialize() != MH_OK)
        {
            return 1;
        }*/
    }
    else {
        Intf->Log("... failed to initialize Minhook\r\n");
    }

    return false;
}

BOOL WINAPI DllMain(HINSTANCE hInstance, uint32_t dwReason, void* pReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) {
		SetHooks();
	}

	return TRUE;
}