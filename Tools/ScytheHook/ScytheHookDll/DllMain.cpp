#include "StdAfx.h"
#include "MinHook.h"

using namespace std;

#ifdef _WIN64
#pragma comment(lib, "libMinHook-x64-v142-mt.lib")
#else
#pragma comment(lib, "libMinHook-x86-v142-mt.lib")
#endif

typedef NTSTATUS (NTAPI *NtMapViewOfSection_t)(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG InheritDisposition, ULONG AllocationType, ULONG Win32Protect);
//typedef NTSTATUS (NTAPI *NtAllocateVirtualMemory_t)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);

typedef int (WINAPI* MESSAGEBOXW)(HWND, LPCWSTR, LPCWSTR, UINT);
//typedef LONG(NTAPI* NtMapViewOfSection_t)(HANDLE, HANDLE, PVOID*, ULONG_PTR, SIZE_T, PLARGE_INTEGER, PSIZE_T, DWORD, ULONG, ULONG);

Interface *Intf;
NtAllocateVirtualMemory_t gpNtAllocateVirtualMemoryTrampoline = nullptr;
NtMapViewOfSection_t gpNtMapViewOfSectionTrampoline = nullptr;

bool GetProcessName(uint32_t dwPID, wchar_t *ProcessName, uint32_t ccProcessNameLen) {
    HANDLE hProcess;
    uint32_t dwOutLen = ccProcessNameLen;
    bool bSuccess = false;

    if ((hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwPID)) != NULL) {
        if (QueryFullProcessImageNameW(hProcess, 0, ProcessName, (PDWORD)&dwOutLen)) {
            bSuccess = true;
        }

        CloseHandle(hProcess);
    }

    return bSuccess;
}

NTSTATUS NTAPI DetourNtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect) {
    bool bInteresting = false;
    wchar_t CurrentProcessName[MAX_PATH + 1] = { 0 };
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
        if (dwTargetPid != GetCurrentProcessId()) {
            wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

            GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
            bInteresting = true;
            GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
            Intf->Log("[%ws : %d] Remote NtAllocateVirtualMemory to %d (%ws)\r\n", CurrentProcessName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
        }
    }
    else {
        GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
        Intf->Log("[%ws : %d] Unknown NtAllocateVirtualMemory PID associated with handle 0x%p\r\n", CurrentProcessName, GetCurrentProcessId(), ProcessHandle);
    }

    if (Protect == 0x40) {
        bInteresting = true;
        GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
        Intf->Log("[%ws : %d] NtAllocateVirtualMemory +RWX\r\n", CurrentProcessName, GetCurrentProcessId());
    }

    NTSTATUS NtStatus = gpNtAllocateVirtualMemoryTrampoline(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);

    if (bInteresting) {
        Intf->Log("\r\n... NtAllocateVirtualMemory called with parameters:\r\n");
        Intf->Log("    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log("    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log("    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log("    RegionSize: 0x%08x\r\n", RegionSize);
        Intf->Log("    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log("    Protect: 0x%08x\r\n", Protect);
        Intf->Log("\r\n\r\n");
    }

    return NtStatus;
}

NTSTATUS NTAPI DetourNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, ULONG InheritDisposition, ULONG AllocationType, ULONG Win32Protect) {
    bool bInteresting = false;
    wchar_t CurrentProcessName[MAX_PATH + 1] = { 0 };
    uint32_t dwTargetPid = GetProcessId(ProcessHandle);

    if (dwTargetPid) { // In the event that the handle does not have PROCESS_QUERY_LIMITED_INFORMATION, we can't query its PID
        if (dwTargetPid != GetCurrentProcessId()) {
            wchar_t TargetProcessName[MAX_PATH + 1] = { 0 };

            GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
            bInteresting = true;
            GetProcessName(dwTargetPid, TargetProcessName, MAX_PATH + 1);
            Intf->Log("[%ws : %d] Remote NtMapViewOfSection to %d (%ws)\r\n", CurrentProcessName, GetCurrentProcessId(), dwTargetPid, TargetProcessName);
        }
    }
    else {
        GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
        Intf->Log("[%ws : %d] Unknown NtMapViewOfSection PID associated with handle 0x%p\r\n", CurrentProcessName, GetCurrentProcessId(), ProcessHandle);
    }

    if (Win32Protect == 0x40) {
        bInteresting = true;
        GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);
        Intf->Log("[%ws : %d] NtMapViewOfSection +RWX section mapping\r\n", CurrentProcessName, GetCurrentProcessId());
    }

    NTSTATUS NtStatus = gpNtMapViewOfSectionTrampoline(SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);

    if (bInteresting) {
        Intf->Log("\r\n... NtMapViewOfSection called with parameters:\r\n");
        Intf->Log("    SectionHandle: 0x%p\r\n", SectionHandle);
        Intf->Log("    ProcessHandle: 0x%p\r\n", ProcessHandle);
        Intf->Log("    BaseAddress: 0x%p : 0x%p\r\n", BaseAddress, *BaseAddress);
        Intf->Log("    ZeroBits: 0x%p\r\n", ZeroBits);
        Intf->Log("    CommitSize: 0x%08x\r\n", CommitSize);
        Intf->Log("    SectionOffset: 0x%p\r\n", SectionOffset);
        Intf->Log("    ViewSize: 0x%p : %d\r\n", ViewSize, *ViewSize);
        Intf->Log("    InheritDisposition: 0x%08x\r\n", InheritDisposition);
        Intf->Log("    AllocationType: 0x%08x\r\n", AllocationType);
        Intf->Log("    Win32Protect: 0x%08x\r\n", Win32Protect);
        Intf->Log("\r\n\r\n");
    }

    return NtStatus;
}
//HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs
bool SetHooks() {
    HMODULE hNtdllModule = GetModuleHandleW(L"ntdll.dll");
    NtMapViewOfSection_t NtMapViewOfSection = (NtMapViewOfSection_t)GetProcAddress(hNtdllModule, "NtMapViewOfSection");
    NtAllocateVirtualMemory_t NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hNtdllModule, "NtAllocateVirtualMemory");
    wchar_t CurrentProcessName[MAX_PATH + 1] = { 0 };

    //Intf = new Interface(L"C:\\Users\\Forrest\\Documents\\GitHub\\ExploitDev\\Tools\\ScytheHook\\Release\\\ScytheHook.log");
    Intf = new Interface(L"C:\\ProgramData\\ScytheHook.log");
    GetModuleFileNameW(nullptr, CurrentProcessName, MAX_PATH + 1);

    Intf->Log("... setting hooks within %ws (PID %d)...\r\n", CurrentProcessName, GetCurrentProcessId());

    if (MH_Initialize() == MH_OK) {
        if (MH_CreateHook(NtMapViewOfSection, &DetourNtMapViewOfSection, reinterpret_cast<LPVOID*>(&gpNtMapViewOfSectionTrampoline)) == MH_OK) {
            if (MH_EnableHook(NtMapViewOfSection) == MH_OK) {
                if (MH_CreateHook(NtAllocateVirtualMemory, &DetourNtAllocateVirtualMemory, reinterpret_cast<LPVOID*>(&gpNtAllocateVirtualMemoryTrampoline)) == MH_OK) {
                    if (MH_EnableHook(NtAllocateVirtualMemory) == MH_OK) {
                        //Intf->Log("... successfully set and enabled hook on NtMapViewOfSection at 0x%p\r\n", NtMapViewOfSection);
                        return true;
                    }
                }
            }
            else {
                Intf->Log("... failed to enable hook on NtMapViewOfSection at 0x%p\r\n", NtMapViewOfSection);
            }
        }
        else {
            Intf->Log("... failed to set hook on NtMapViewOfSection at 0x%p\r\n", NtMapViewOfSection);
        }
    }
    else {
        Intf->Log("... failed to initialize Minhook\r\n");
    }

    return false;
}

BOOL WINAPI DllMain(HINSTANCE hInstance, uint32_t dwReason, void* pReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) {
		SetHooks();
	}

	return TRUE;
}